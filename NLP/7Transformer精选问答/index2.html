<!DOCTYPE html>
<!-- saved from url=(0029)http://121.199.45.168:8022/2/ -->
<html lang="zh" class="js json svg checked target dataset details fetch supports csstransforms3d no-ios" style=""><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    
      
      <meta name="viewport" content="width=device-width,initial-scale=1">
      <meta http-equiv="x-ua-compatible" content="ie=edge">
      
      
        <link rel="canonical" href="#">
      
      
      
        <meta name="lang:clipboard.copy" content="复制">
      
        <meta name="lang:clipboard.copied" content="已复制">
      
        <meta name="lang:search.language" content="ja">
      
        <meta name="lang:search.pipeline.stopwords" content="True">
      
        <meta name="lang:search.pipeline.trimmer" content="True">
      
        <meta name="lang:search.result.none" content="没有找到符合条件的结果">
      
        <meta name="lang:search.result.one" content="找到 1 个符合条件的结果">
      
        <meta name="lang:search.result.other" content="# 个符合条件的结果">
      
        <meta name="lang:search.tokenizer" content="[\uff0c\u3002]+">
      
      <link rel="shortcut icon" href="./index_files/AI.jpg">
      <meta name="generator" content="mkdocs-1.1.2, mkdocs-material-4.4.0">
    
    
      
        <title>2. ELMo, GPT等经典模型的介绍与对比 - 学习手册</title>
      
    
    
      <link rel="stylesheet" href="./index_files/application.0284f74d.css">
      
      
    
    
      <script src="./index_files/modernizr.74668098.js"></script>
    
    
      
        <link href="https://fonts.gstatic.com/" rel="preconnect" crossorigin="">
        <link rel="stylesheet" href="./index_files/css">
        <style>body,input{font-family:"Roboto","Helvetica Neue",Helvetica,Arial,sans-serif}code,kbd,pre{font-family:"Roboto Mono","Courier New",Courier,monospace}</style>
      
    
    <link rel="stylesheet" href="./index_files/material-icons.css">
    
    
    
      
        
<script>
  window.ga = window.ga || function() {
    (ga.q = ga.q || []).push(arguments)
  }
  ga.l = +new Date
  /* Setup integration and send page view */
  ga("create", "UA-36723568-3", "mkdocs.org")
  ga("set", "anonymizeIp", true)
  ga("send", "pageview")
  /* Register handler to log search on blur */
  document.addEventListener("DOMContentLoaded", () => {
    if (document.forms.search) {
      var query = document.forms.search.query
      query.addEventListener("blur", function() {
        if (this.value) {
          var path = document.location.pathname;
          ga("send", "pageview", path + "?q=" + this.value)
        }
      })
    }
  })
</script>
<script async="" src="./index_files/analytics.js"></script>
      
    
    
  <script type="text/javascript">(function(){var s=document.createElement("script");var port=window.location.port;s.src="//"+window.location.hostname+":"+port+ "/livereload.js?port=" + port;document.head.appendChild(s);})();</script><script src="./index_files/livereload.js"></script></head>
  
    <body dir="ltr" data-md-state="">
  
    <svg class="md-svg">
      <defs>
        
        
          <svg xmlns="http://www.w3.org/2000/svg" width="416" height="448" viewBox="0 0 416 448" id="__github"><path fill="currentColor" d="M160 304q0 10-3.125 20.5t-10.75 19T128 352t-18.125-8.5-10.75-19T96 304t3.125-20.5 10.75-19T128 256t18.125 8.5 10.75 19T160 304zm160 0q0 10-3.125 20.5t-10.75 19T288 352t-18.125-8.5-10.75-19T256 304t3.125-20.5 10.75-19T288 256t18.125 8.5 10.75 19T320 304zm40 0q0-30-17.25-51T296 232q-10.25 0-48.75 5.25Q229.5 240 208 240t-39.25-2.75Q130.75 232 120 232q-29.5 0-46.75 21T56 304q0 22 8 38.375t20.25 25.75 30.5 15 35 7.375 37.25 1.75h42q20.5 0 37.25-1.75t35-7.375 30.5-15 20.25-25.75T360 304zm56-44q0 51.75-15.25 82.75-9.5 19.25-26.375 33.25t-35.25 21.5-42.5 11.875-42.875 5.5T212 416q-19.5 0-35.5-.75t-36.875-3.125-38.125-7.5-34.25-12.875T37 371.5t-21.5-28.75Q0 312 0 260q0-59.25 34-99-6.75-20.5-6.75-42.5 0-29 12.75-54.5 27 0 47.5 9.875t47.25 30.875Q171.5 96 212 96q37 0 70 8 26.25-20.5 46.75-30.25T376 64q12.75 25.5 12.75 54.5 0 21.75-6.75 42 34 40 34 99.5z"></path></svg>
        
      </defs>
    </svg>
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" data-md-component="overlay" for="__drawer"></label>
    
      <a href="#21-elmo" tabindex="1" class="md-skip">
        跳转至
      </a>
    
    
      <header class="md-header" data-md-component="header" data-md-state="shadow">
  <nav class="md-header-nav md-grid">
    <div class="md-flex">
      <div class="md-flex__cell md-flex__cell--shrink">
        <a href="#" title="学习手册" class="md-header-nav__button md-logo">
          
            <img src="./index_files/AI.jpg" width="24" height="24">
          
        </a>
      </div>
      <div class="md-flex__cell md-flex__cell--shrink">
        <label class="md-icon md-icon--menu md-header-nav__button" for="__drawer"></label>
      </div>
      <div class="md-flex__cell md-flex__cell--stretch">
        <div class="md-flex__ellipsis md-header-nav__title" data-md-component="title">
          
            <span class="md-header-nav__topic" style="width: 648px;">
              学习手册
            </span>
            <span class="md-header-nav__topic" style="width: 648px;">
              
                2. ELMo, GPT等经典模型的介绍与对比
              
            </span>
          
        </div>
      </div>
      <div class="md-flex__cell md-flex__cell--shrink">
        
          <label class="md-icon md-icon--search md-header-nav__button" for="__search"></label>
          
<div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" placeholder="搜索" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="query" data-md-state="active">
      <label class="md-icon md-search__icon" for="__search"></label>
      <button type="reset" class="md-icon md-search__icon" data-md-component="reset" tabindex="-1">
        
      </button>
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix="">
        <div class="md-search-result" data-md-component="result">
          <div class="md-search-result__meta">
            键入以开始搜索
          </div>
          <ol class="md-search-result__list"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
        
      </div>
      
        <div class="md-flex__cell md-flex__cell--shrink">
          <div class="md-header-nav__source">
            


  

<a href="https://github.com/AITutorials/manuals" title="前往 Github 仓库" class="md-source" data-md-source="github" data-md-state="done">
  
    <div class="md-source__icon">
      <svg viewBox="0 0 24 24" width="24" height="24">
        <use xlink:href="#__github" width="24" height="24"></use>
      </svg>
    </div>
  
  <div class="md-source__repository">
    Github
  </div>
</a>
          </div>
        </div>
      
    </div>
  </nav>
</header>
    
    <div class="md-container">
      
        
      
      
      <main class="md-main">
        <div class="md-main__inner md-grid" data-md-component="container">
          
            
              <div class="md-sidebar md-sidebar--primary" data-md-component="navigation" style="height: 757px;">
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    <nav class="md-nav md-nav--primary" data-md-level="0">
  <label class="md-nav__title md-nav__title--site" for="__drawer">
    <a href="#" title="学习手册" class="md-nav__button md-logo">
      
        <img src="./index_files/AI.jpg" width="48" height="48">
      
    </a>
    学习手册
  </label>
  
    <div class="md-nav__source">
      


  

<a href="https://github.com/AITutorials/manuals" title="前往 Github 仓库" class="md-source" data-md-source="github" data-md-state="done">
  
    <div class="md-source__icon">
      <svg viewBox="0 0 24 24" width="24" height="24">
        <use xlink:href="#__github" width="24" height="24"></use>
      </svg>
    </div>
  
  <div class="md-source__repository">
    Github
  </div>
</a>
    </div>
  
  <ul class="md-nav__list" data-md-scrollfix="">
    
      
      
      


  <li class="md-nav__item">
    <a href="./index.html" title="1. BERT,Transformer的模型架构与详解" class="md-nav__link">
      1. BERT,Transformer的模型架构与详解
    </a>
  </li>

    
      
      
      

  


  <li class="md-nav__item md-nav__item--active">
    
    <input class="md-toggle md-nav__toggle" data-md-toggle="toc" type="checkbox" id="__toc">
    
    
      <label class="md-nav__link md-nav__link--active" for="__toc">
        2. ELMo, GPT等经典模型的介绍与对比
      </label>
    
    <a href="#" title="2. ELMo, GPT等经典模型的介绍与对比" class="md-nav__link md-nav__link--active">
      2. ELMo, GPT等经典模型的介绍与对比
    </a>
    
      
<nav class="md-nav md-nav--secondary">
  
  
  
    <label class="md-nav__title" for="__toc">目录</label>
    <ul class="md-nav__list" data-md-scrollfix="">
      
        <li class="md-nav__item">
  <a href="#21-elmo" title="2.1 认识ELMo" class="md-nav__link">
    2.1 认识ELMo
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_1" title="学习目标" class="md-nav__link">
    学习目标
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#elmo" title="什么是ELMo" class="md-nav__link">
    什么是ELMo
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#elmo_1" title="ELMo的架构" class="md-nav__link">
    ELMo的架构
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#elmo_2" title="ELMo的预训练任务" class="md-nav__link">
    ELMo的预训练任务
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#elmo_3" title="ELMo模型的效果" class="md-nav__link">
    ELMo模型的效果
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#elmo_4" title="ELMo的待改进点" class="md-nav__link">
    ELMo的待改进点
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_2" title="小节总结" class="md-nav__link">
    小节总结
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#22-gpt" title="2.2 认识GPT" class="md-nav__link">
    2.2 认识GPT
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_3" title="学习目标" class="md-nav__link">
    学习目标
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#gpt" title="什么是GPT" class="md-nav__link">
    什么是GPT
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#gpt_1" title="GPT的架构" class="md-nav__link">
    GPT的架构
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#gpt_2" title="GPT训练过程" class="md-nav__link">
    GPT训练过程
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_4" title="小节总结" class="md-nav__link">
    小节总结
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#23-gpt2" title="2.3 认识GPT2" class="md-nav__link">
    2.3 认识GPT2
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_5" title="学习目标" class="md-nav__link">
    学习目标
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#gpt2" title="GPT2的架构" class="md-nav__link">
    GPT2的架构
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#gpt2_1" title="GPT2模型的细节" class="md-nav__link">
    GPT2模型的细节
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_6" title="小节总结" class="md-nav__link">
    小节总结
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#24-bert-gpt-elmo" title="2.4 请详述BERT, GPT, ELMo模型的对比和各自的优缺点?" class="md-nav__link">
    2.4 请详述BERT, GPT, ELMo模型的对比和各自的优缺点?
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_7" title="学习目标" class="md-nav__link">
    学习目标
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#bert-gpt-elmo" title="BERT, GPT, ELMo之间的不同点" class="md-nav__link">
    BERT, GPT, ELMo之间的不同点
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#bert-gpt-elmo_1" title="BERT, GPT, ELMo各自的优点和缺点" class="md-nav__link">
    BERT, GPT, ELMo各自的优点和缺点
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_8" title="小节总结" class="md-nav__link">
    小节总结
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
      
      
      
      
    </ul>
  
</nav>
    
  </li>

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              <div class="md-sidebar md-sidebar--secondary" data-md-component="toc" style="height: 757px;">
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    
<nav class="md-nav md-nav--secondary">
  
  
  
    <label class="md-nav__title" for="__toc">目录</label>
    <ul class="md-nav__list" data-md-scrollfix="">
      
        <li class="md-nav__item">
  <a href="#21-elmo" title="2.1 认识ELMo" class="md-nav__link">
    2.1 认识ELMo
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_1" title="学习目标" class="md-nav__link">
    学习目标
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#elmo" title="什么是ELMo" class="md-nav__link">
    什么是ELMo
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#elmo_1" title="ELMo的架构" class="md-nav__link">
    ELMo的架构
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#elmo_2" title="ELMo的预训练任务" class="md-nav__link">
    ELMo的预训练任务
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#elmo_3" title="ELMo模型的效果" class="md-nav__link">
    ELMo模型的效果
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#elmo_4" title="ELMo的待改进点" class="md-nav__link">
    ELMo的待改进点
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_2" title="小节总结" class="md-nav__link">
    小节总结
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#22-gpt" title="2.2 认识GPT" class="md-nav__link">
    2.2 认识GPT
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_3" title="学习目标" class="md-nav__link">
    学习目标
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#gpt" title="什么是GPT" class="md-nav__link">
    什么是GPT
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#gpt_1" title="GPT的架构" class="md-nav__link">
    GPT的架构
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#gpt_2" title="GPT训练过程" class="md-nav__link">
    GPT训练过程
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_4" title="小节总结" class="md-nav__link">
    小节总结
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#23-gpt2" title="2.3 认识GPT2" class="md-nav__link">
    2.3 认识GPT2
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_5" title="学习目标" class="md-nav__link">
    学习目标
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#gpt2" title="GPT2的架构" class="md-nav__link">
    GPT2的架构
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#gpt2_1" title="GPT2模型的细节" class="md-nav__link">
    GPT2模型的细节
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_6" title="小节总结" class="md-nav__link">
    小节总结
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#24-bert-gpt-elmo" title="2.4 请详述BERT, GPT, ELMo模型的对比和各自的优缺点?" class="md-nav__link">
    2.4 请详述BERT, GPT, ELMo模型的对比和各自的优缺点?
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_7" title="学习目标" class="md-nav__link">
    学习目标
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#bert-gpt-elmo" title="BERT, GPT, ELMo之间的不同点" class="md-nav__link">
    BERT, GPT, ELMo之间的不同点
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#bert-gpt-elmo_1" title="BERT, GPT, ELMo各自的优点和缺点" class="md-nav__link">
    BERT, GPT, ELMo各自的优点和缺点
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_8" title="小节总结" class="md-nav__link">
    小节总结
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
      
      
      
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          <div class="md-content">
            <article class="md-content__inner md-typeset">
              
                
                
                  <h1>2. ELMo, GPT等经典模型的介绍与对比</h1>
                
                <h2 id="21-elmo">2.1 认识ELMo</h2>
<hr>
<h3 id="_1">学习目标</h3>
<ul>
<li>了解什么是ELMo.</li>
<li>掌握ELMo的架构.</li>
<li>掌握ELMo的预训练任务.</li>
<li>了解ELMo的效果和成绩.</li>
<li>了解ELMo的优缺点.</li>
</ul>
<hr>
<h3 id="elmo">什么是ELMo</h3>
<ul>
<li>ELMo是2018年3月由华盛顿大学提出的一种预训练模型.<ul>
<li>ELMo的全称是Embeddings from Language Models.</li>
<li>ELMo模型的提出源于论文<a href="https://arxiv.org/abs/1802.05365">&lt;&lt; Deep Contextualized Word Representations &gt;&gt;</a>.</li>
<li>ELMo模型提出的动机源于研究人员认为一个好的预训练语言模型应该能够包含丰富的句法和语义信息, 并且能够对多义词进行建模. 而传统的词向量(2013年的word2vec, 2014年的GloVe)都是上下文无关的, 也就是固定的词向量. 最典型的例子就是"apple"在不同的语境下, 应该可以表示水果或公司, 但是固定的词向量显然无法做到这一点. 因为研究团队利用新的语言模型训练一个上下文相关的预训练模型, 成为ELMo, 并在6个NLP任务上获得提升.</li>
</ul>
</li>
</ul>
<hr>
<h3 id="elmo_1">ELMo的架构</h3>
<ul>
<li>总体架构: 如下图所示就是ELMo的架构图.</li>
</ul>
<p></p><center><img src="./index_files/picture_21.png" height="auto" width="auto"></center><p></p>
<hr>
<ul>
<li>从上面的架构图中可以看到, 宏观上ELMo分三个主要模块.<ul>
<li>最底层黄色标记的Embedding模块.</li>
<li>中间层蓝色标记的两部分双层LSTM模块.</li>
<li>最上层绿色标记的词向量表征模块.</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>Embedding模块: ELMo最底层的词嵌入采用CNN对字符级进行编码, 本质就是获得一个静态的词嵌入向量作为网络的底层输入.</li>
</ul>
<hr>
<ul>
<li>两部分的双层LSTM模块: <ul>
<li>这是整个ELMo中最重要的部分, 架构中分成左侧的前向LSTM网络, 和右侧的反向LSTM网络.</li>
<li>ELMo的做法是我们只预训练一个Language Model, 而word embedding是通过输入的句子实时给出的, 这样单词的嵌入向量就包含了上下文的信息, 也就彻底改变了Word2Vec和GloVe的静态词向量的做法.</li>
</ul>
</li>
</ul>
<hr>
<blockquote>
<ul>
<li>ELMo的这一模块分为左右两部分, 本质上就是一个双向LM, 对于左半部分, 给定了N个tokens(t1, t2, ..., tN), Language Model通过前面k-1个位置的token序列来计算第k个token出现的概率, 构成前向双层LSTM模型.</li>
</ul>
</blockquote>
<p></p><center><img src="./index_files/picture_22.png" height="auto" width="auto"></center><p></p>
<hr>
<blockquote>
<ul>
<li>同理, 对于架构中的右半部分, 给定了N个tokens(t(k+1), t(k+2), ..., t(N)), Language Model通过后面N-k个位置的token序列来计算第k个token出现的概率, 构成后向双层LSTM模型.</li>
</ul>
</blockquote>
<p></p><center><img src="./index_files/picture_23.png" height="auto" width="auto"></center><p></p>
<hr>
<blockquote>
<ul>
<li>ELMo在训练过程中的目标函数就是最大化下面的公式:</li>
</ul>
</blockquote>
<p></p><center><img src="./index_files/picture_24.png" height="auto" width="auto"></center><p></p>
<hr>
<ul>
<li>词向量表征模块: </li>
</ul>
<blockquote>
<ul>
<li>因为ELMo是个语言模型, 对于每个token, 通过一个L层的双向LSTM网络可以计算出2L+1个表示向量如下:</li>
</ul>
</blockquote>
<p></p><center><img src="./index_files/picture_25.png" height="auto" width="auto"></center><p></p>
<hr>
<blockquote>
<ul>
<li>从上面的公式可以清楚的看到, 有3个不同的组成部分, 第一个就是对token直接进行CNN编码的结果, 也是ELMo最底层模块的输出; 第二个就是前向LSTM的输出结果, 每一层都会有一个输出, 总共L层就会有L个输出; 第三个就是后向LSTM的输出结果, 每一层都会有一个输出, 总共L层就会有L个输出; 综合三部分的输出加在一起, 就是2L+1个输出向量.</li>
</ul>
</blockquote>
<hr>
<blockquote>
<ul>
<li>通过整个网络, 每一个token得到了2L+1个表示向量, 但是我们希望每一个token能对应一个向量. 最简单的做法就是取最上层的输出结果作为token的表示向量, 更通用的做法是加入若干参数来融合所有层的信息, 如下所示:</li>
</ul>
</blockquote>
<p></p><center><img src="./index_files/picture_26.png" height="auto" width="auto"></center><p></p>
<hr>
<blockquote>
<ul>
<li>
<p>上式的意思是对于2L+1个向量, 每一个前面都加上一个权重稀疏, 然后直接融合成一个向量, 最后再乘一个系数作为最终该token的词向量.</p>
</li>
<li>
<p>原始论文中提到最前面的那个系数, 在不同任务中取不同的值效果会有较大的差异, 需要注意在SQuAD中设置为0.01取得的效果要好于设置为1.</p>
</li>
<li>
<p>原始论文中在进行底层token编码时, 用CNN形成了一个512维的列向量, 也就是初始嵌入维度等于512. 中间层使用了双层的LSTM分别进行前向编码和后向编码, 每层的单个LSTM输入维度是512, 输出维度也是512, 保持一致. 因为是双向编码并且分左右两部分, 所以每层的输出维度是512*2=1024, 最后进行权重融合后的向量维度就是1024.</p>
</li>
</ul>
</blockquote>
<hr>
<h3 id="elmo_2">ELMo的预训练任务</h3>
<ul>
<li>ELMo的本质思想:<ul>
<li>首先用一个语言模型学好一个单词的word embedding, 此时是无法区分多义词的, 但没关系. 当实际使用word embedding的时候, 该单词已经具备了特定的上下文信息, 这个时候可以根据上下文单词的语义去调整单词的word embedding表示, 这样经过调整后得到的word embedding向量就可以准确的表达单词在当前上下文中的真实含义了, 也就自然的解决了多义词问题.</li>
<li>结论就是ELMo模型是个根据当前上下文对word embedding动态调整的语言模型.</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>ELMo的预训练采用了典型的两阶段过程:<ul>
<li>第一阶段: 利用语言模型进行预训练.</li>
<li>第二阶段: 在做下游任务时, 从预训练网络中提取对应单词的网络各层的word embedding作为新特征补充到下游任务中.</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>第一阶段: 语言模型预训练.<ul>
<li>再次回到ELMo的总体架构图, 网络结构采用了双层双向LSTM. </li>
</ul>
</li>
</ul>
<hr>
<blockquote>
<ul>
<li>目前语言模型训练的任务目标是根据单词Wi的上下文去正确预测单词Wi, Wi之前的单词序列context-before称为上文, Wi之后的单词序列context-after称为下文. </li>
</ul>
</blockquote>
<hr>
<blockquote>
<ul>
<li>架构图上左侧的前向双层LSTM代表正方向编码器, 输入的是从左向右顺序的除了预测单词Wi之外的上文context-before; 右侧的反向双层LSTM代表反方向编码器, 输入的是从右向左的逆序的下文context-after;</li>
</ul>
</blockquote>
<hr>
<blockquote>
<ul>
<li>每个编码器的深度都是L=2, 即双层LSTM叠加.</li>
</ul>
</blockquote>
<hr>
<blockquote>
<ul>
<li>使用上述的网络结构利用大量语料做语言模型任务就能预训练好这个网络. 当输入一个新句子S_new时, 句子中每个单词都能得到对应的3个embedding向量: 1-最底层的单词的word embedding. 2-中间第一层双向LSTM中对应单词位置的embedding, 这层编码对应单词的句法信息更多一些. 3-中间第二层双向LSTM中对应单词位置的embedding, 这层编码对应单词的语义信息更多一些.</li>
</ul>
</blockquote>
<hr>
<blockquote>
<ul>
<li>ELMo的预训练过程不仅仅学会了单词的word embedding, 还学习了一个双层双向的LSTM网络, 这两者后续都会用到, 是整个ELMo预训练的两大产出结果.</li>
</ul>
</blockquote>
<hr>
<ul>
<li>第二阶段: 下游任务的调整.<ul>
<li>比如我们的下游任务是QA问题.</li>
</ul>
</li>
</ul>
<hr>
<blockquote>
<ul>
<li>对于问句X, 可以先将句子X作为预训练好的ELMo网络的输入, 这样X中每个单词在ELMo中都能获得3个对应的embedding向量. 之后赋给这3个向量各自一个权重a, 这个权重a既可以是学习得来的也可以是最简单的平均分布赋值, 然后把3个向量加权求和, 整个成一个词向量. 最后将整合后的词向量作为X在自己任务的那个网络结构中对应单词的输入, 以此作为新特征补充进下游任务中. 对于回答Y可以同样处理.</li>
</ul>
</blockquote>
<hr>
<blockquote>
<ul>
<li>因为ELMo给下游提供的是每个单词的特征形式, 所以这一类预训练方法被称为"Feature-based Pre-Training".</li>
</ul>
</blockquote>
<hr>
<h3 id="elmo_3">ELMo模型的效果</h3>
<ul>
<li>ELMo对于多义词问题的解决结果:</li>
</ul>
<p></p><center><img src="./index_files/picture_27.png" height="auto" width="auto"></center><p></p>
<hr>
<blockquote>
<ul>
<li>前面提到静态的word embedding无法解决多义词的问题, 那么ELMo引入上下文动态语义调整后的embedding word可以解决多义词问题吗? 答案正如上图所示, 而且比我们期待的解决效果要更好.</li>
</ul>
</blockquote>
<hr>
<blockquote>
<ul>
<li>上图中的例子, 对于GloVe训练出来的word embedding来说, 多义词比如play, 根据它的embedding找出最接近其语义的单词, 发现结果集合几乎全部都在体育领域, 这很明显是因为训练数据中包含play的语句中体育领域的数量明显占多数导致的.</li>
</ul>
</blockquote>
<hr>
<blockquote>
<ul>
<li>再来看使用ELMo后的效果, 根据上下文动态调整后的embedding word不仅仅能找出对应于"play":"演出"的相同语义的句子, 而且还可以保证找出的句子中的play对应的词性也是相同的, 这真的是超出期待之外的惊喜!</li>
</ul>
</blockquote>
<hr>
<blockquote>
<ul>
<li>原始论文中提到ELMo的试验效果, 在6个NLP主流任务中性能都有不同幅度的提升, 最高的提升达到25%, 任务的覆盖范围很广, 包含句子语义关系判断, 分类任务, 阅读理解等等.</li>
</ul>
</blockquote>
<hr>
<h3 id="elmo_4">ELMo的待改进点</h3>
<ul>
<li>ELMo在传统静态word embedding方法(Word2Vec, GloVe)的基础上提升了很多, 但是依然存在缺陷, 有很大的改进余地.<ul>
<li>第一点: 一个很明显的缺点在于特征提取器的选择上, ELMo使用了双向双层LSTM, 而不是现在横扫千军的Transformer, 在特征提取能力上肯定是要弱一些的. 设想如果ELMo的提升提取器选用Transformer, 那么后来的BERT的反响将远不如当时那么火爆了.</li>
<li>第二点: ELMo选用双向拼接的方式进行特征融合, 这种方法肯定不如BERT一体化的双向提取特征好.</li>
</ul>
</li>
</ul>
<hr>
<h3 id="_2">小节总结</h3>
<ul>
<li>
<p>学习了什么是ELMo.</p>
<ul>
<li>ELMo是2018年3月由华盛顿大学提出的一种预训练语言模型.</li>
<li>ELMo在6种NLP测试任务中有很大的提升表现.</li>
</ul>
</li>
<li>
<p>学习了ELMo的结构.</p>
<ul>
<li>ELMo架构总体上采用了双向双层LSTM的结构.</li>
<li>最底层的Embedding模块.</li>
<li>中间层的双向双层LSTM模块.</li>
<li>最上层的特征融合模块.</li>
</ul>
</li>
<li>
<p>学习了ELMo的预训练任务.</p>
<ul>
<li>ELMo的本质思想就是根据当前上下文对word embedding进行动态调整的语言模型.</li>
<li>ELMo的预训练是一个明显的两阶段过程.<ul>
<li>第一阶段: 利用语言模型进行预训练, 得到基础静态词向量和双向双层LSTM网络.</li>
<li>第二阶段: 在拥有上下文的环境中, 将上下文输入双向双层LSTM中, 得到动态调整后的word embedding, 等于将单词融合进了上下文的语义, 可以更准确的表达单词的真实含义.</li>
</ul>
</li>
</ul>
</li>
<li>
<p>学习了ELMo的效果.</p>
<ul>
<li>经过与GloVe静态词向量的对比, 明显可以看出ELMo的词向量可以更好的表达真实语义, 更好的解决多义词的问题.</li>
</ul>
</li>
<li>
<p>学习了ELMo的待改进点.</p>
<ul>
<li>ELMo的特征提取器没有选用更强大的Transformer, 在提取特征上肯定弱于现在的最优结果.</li>
</ul>
</li>
</ul>
<hr>
<hr>
<hr>
<h2 id="22-gpt">2.2 认识GPT</h2>
<hr>
<h3 id="_3">学习目标</h3>
<ul>
<li>了解什么是GPT.</li>
<li>掌握GPT的架构.</li>
<li>掌握GPT的预训练任务.</li>
</ul>
<hr>
<h3 id="gpt">什么是GPT</h3>
<ul>
<li>
<p>GPT是OpenAI公司提出的一种语言预训练模型.</p>
<ul>
<li>OpenAI在论文<a href="https://s3-us-west-2.amazonaws.com/openai-assets/research-covers/language-unsupervised/language_understanding_paper.pdf">&lt;&lt; Improving Language Understanding by Generative Pre-Training &gt;&gt;</a>中提出GPT模型.</li>
<li>OpenAI后续又在论文<a href="https://cdn.openai.com/better-language-models/language_models_are_unsupervised_multitask_learners.pdf">&lt;&lt; Language Models are Unsupervised Multitask Learners &gt;&gt;</a>中提出GPT2模型.</li>
<li>GPT和GPT2模型结构差别不大, 但是GPT2采用了更大的数据集进行训练.</li>
</ul>
</li>
<li>
<p>OpenAI GPT模型是在Google BERT模型之前提出的, 与BERT最大的区别在于GPT采用了传统的语言模型方法进行预训练, 即使用单词的上文来预测单词, 而BERT是采用了双向上下文的信息共同来预测单词.</p>
<ul>
<li>正是因为训练方法上的区别, 使得GPT更擅长处理自然语言生成任务(NLG), 而BERT更擅长处理自然语言理解任务(NLU).</li>
</ul>
</li>
</ul>
<hr>
<h3 id="gpt_1">GPT的架构</h3>
<ul>
<li>再次看三个语言模型的对比架构图, 中间的就是GPT:</li>
</ul>
<p></p><center><img src="./index_files/BERT.png" height="auto" width="auto"></center><p></p>
<hr>
<blockquote>
<ul>
<li>从上图可以很清楚的看到GPT采用的是单向Transformer模型, 例如给定一个句子[u1, u2, ..., un], GPT在预测单词ui的时候只会利用[u1, u2, ..., u(i-1)]的信息, 而BERT会同时利用上下文的信息[u1, u2, ..., u(i-1), u(i+1), ..., un].</li>
</ul>
</blockquote>
<hr>
<blockquote>
<ul>
<li>作为两大模型的直接对比, BERT采用了Transformer的Encoder模块, 而GPT采用了Transformer的Decoder模块. 并且GPT的Decoder Block和经典Transformer Decoder Block还有所不同, 如下图所示:</li>
</ul>
</blockquote>
<p></p><center><img src="./index_files/picture_28.png" height="auto" width="auto"></center><p></p>
<hr>
<blockquote>
<ul>
<li>如上图所示, 经典的Transformer Decoder Block包含3个子层, 分别是Masked Multi-Head Attention层, encoder-decoder attention层, 以及Feed Forward层. 但是在GPT中取消了第二个encoder-decoder attention子层, 只保留Masked Multi-Head Attention层, 和Feed Forward层.</li>
</ul>
</blockquote>
<hr>
<blockquote>
<ul>
<li>作为单向Transformer Decoder模型, GPT利用句子序列信息预测下一个单词的时候, 要使用Masked Multi-Head Attention对单词的下文进行遮掩, 来防止未来信息的提前泄露. 例如给定一个句子包含4个单词[A, B, C, D], GPT需要用[A]预测B, 用[A, B]预测C, 用[A, B, C]预测D. 很显然的就是当要预测B时, 需要将[B, C, D]遮掩起来.</li>
</ul>
</blockquote>
<p></p><center><img src="./index_files/picture_29.png" height="auto" width="auto"></center><p></p>
<hr>
<blockquote>
<ul>
<li>具体的遮掩操作是在slef-attention进行softmax之前进行的, 一般的实现是将MASK的位置用一个无穷小的数值-inf来替换, 替换后执行softmax计算得到新的结果矩阵. 这样-inf的位置就变成了0. 如上图所示, 最后的矩阵可以很方便的做到当利用A预测B的时候, 只能看到A的信息; 当利用[A, B]预测C的时候, 只能看到A, B的信息.</li>
</ul>
</blockquote>
<hr>
<blockquote>
<ul>
<li>注意: 对比于经典的Transformer架构, 解码器模块采用了6个Decoder Block; GPT的架构中采用了12个Decoder Block.</li>
</ul>
</blockquote>
<p></p><center><img src="./index_files/picture_37.png" height="auto" width="auto"></center><p></p>
<hr>
<h3 id="gpt_2">GPT训练过程</h3>
<ul>
<li>GPT的训练也是典型的两阶段过程:<ul>
<li>第一阶段: 无监督的预训练语言模型.</li>
<li>第二阶段: 有监督的下游任务fine-tunning.</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>第一阶段: 无监督的预训练语言模型.</li>
</ul>
<blockquote>
<ul>
<li>给定句子U = [u1, u2, ..., un], GPT训练语言模型时的目标是最大化下面的似然函数:</li>
</ul>
</blockquote>
<p></p><center><img src="./index_files/picture_30.png" height="auto" width="auto"></center><p></p>
<hr>
<blockquote>
<ul>
<li>有上述公式可知, GPT是一个单向语言模型, 假设输入张量用h0表示, 则计算公式如下:</li>
</ul>
</blockquote>
<p></p><center><img src="./index_files/picture_31.png" height="auto" width="auto"></center><p></p>
<hr>
<blockquote>
<ul>
<li>其中Wp是单词的位置编码, We是单词本身的word embedding. Wp的形状是[max_seq_len, embedding_dim], We的形状是[vocab_size, embedding_dim].</li>
</ul>
</blockquote>
<hr>
<blockquote>
<ul>
<li>得到输入张量h0后, 要将h0传入GPT的Decoder Block中, 依次得到ht:</li>
</ul>
</blockquote>
<p></p><center><img src="./index_files/picture_32.png" height="auto" width="auto"></center><p></p>
<hr>
<blockquote>
<ul>
<li>最后通过得到的ht来预测下一个单词:</li>
</ul>
</blockquote>
<p></p><center><img src="./index_files/picture_33.png" height="auto" width="auto"></center><p></p>
<hr>
<ul>
<li>第二阶段: 有监督的下游任务fine-tunning.</li>
</ul>
<blockquote>
<ul>
<li>GPT经过预训练后, 会针对具体的下游任务对模型进行微调. 微调采用的是有监督学习, 训练样本包括单词序列[x1, x2, ..., xn]和label y. GPT微调的目标任务是根据单词序列[x1, x2, ..., xn]预测标签y.</li>
</ul>
</blockquote>
<p></p><center><img src="./index_files/picture_34.png" height="auto" width="auto"></center><p></p>
<hr>
<blockquote>
<ul>
<li>其中Wy表示预测输出的矩阵参数, 微调任务的目标是最大化下面的函数:</li>
</ul>
</blockquote>
<p></p><center><img src="./index_files/picture_35.png" height="auto" width="auto"></center><p></p>
<hr>
<blockquote>
<ul>
<li>综合两个阶段的目标任务函数, 可知GPT的最终优化函数为:</li>
</ul>
</blockquote>
<p></p><center><img src="./index_files/picture_36.png" height="auto" width="auto"></center><p></p>
<hr>
<h3 id="_4">小节总结</h3>
<ul>
<li>
<p>学习了什么是GPT.</p>
<ul>
<li>GPT是OpenAI公司提出的一种预训练语言模型.</li>
<li>本质上来说, GPT是一个单向语言模型.</li>
</ul>
</li>
<li>
<p>学习了GPT的架构.</p>
<ul>
<li>GPT采用了Transformer架构中的解码器模块.</li>
<li>GPT在使用解码器模块时做了一定的改造, 将传统的3层Decoder Block变成了2层Block, 删除了encoder-decoder attention子层, 只保留Masked Multi-Head Attention子层和Feed Forward子层.</li>
<li>GPT的解码器总共是由12个改造后的Decoder Block组成的.</li>
</ul>
</li>
<li>
<p>学习了GPT的预训练任务.</p>
<ul>
<li>第一阶段: 无监督的预训练语言模型. 只利用单词前面的信息来预测当前单词.</li>
<li>第二阶段: 有监督的下游任务fine-tunning.</li>
</ul>
</li>
</ul>
<hr>
<hr>
<hr>
<h2 id="23-gpt2">2.3 认识GPT2</h2>
<hr>
<h3 id="_5">学习目标</h3>
<ul>
<li>掌握GPT2的架构</li>
<li>掌握GPT2的训练任务和模型细节</li>
</ul>
<hr>
<h3 id="gpt2">GPT2的架构</h3>
<ul>
<li>从模型架构上看, GPT2并没有特别新颖的架构, 它和只带有解码器模块的Transformer很像.</li>
</ul>
<blockquote>
<ul>
<li>所谓语言模型, 作用就是根据已有句子的一部分, 来预测下一个单词会是什么. 现实应用中大家最熟悉的一个语言模型应用, 就是智能手机上的输入法, 它可以根据当前输入的内容智能推荐下一个要打的字.</li>
</ul>
</blockquote>
<p></p><center><img src="./index_files/picture_38.png" height="auto" width="auto"></center> <p></p>
<hr>
<blockquote>
<ul>
<li>
<p>GPT2也是一个语言预测生成模型, 只不过比手机上应用的模型要大很多, 也更加复杂. 常见的手机端应用的输入法模型基本占用50MB空间, 而OpenAI的研究人员使用了40GB的超大数据集来训练GPT2, 训练后的GPT2模型最小的版本也要占用超过500MB空间来存储所有的参数, 至于最大版本的GPT2则需要超过6.5GB的存储空间.</p>
</li>
<li>
<p>自从Transformer问世以来, 很多预训练语言模型的工作都在尝试将编码器或解码器堆叠的尽可能高, 那类似的模型可以堆叠到多深呢? 事实上, 这个问题的答案也就是区别不同GPT2版本的主要因素之一. 比如最小版本的GPT2堆叠了12层, 中号的24层, 大号的36层, 超大号的堆叠了整整48层!</p>
</li>
</ul>
</blockquote>
<p></p><center><img src="./index_files/picture_39.png" height="auto" width="auto"></center><p></p>
<hr>
<h3 id="gpt2_1">GPT2模型的细节</h3>
<ul>
<li>以机器人第一法则为例, 来具体看GPT2的工作细节.<ul>
<li>机器人第一法则: 机器人不得伤害人类, 或者目睹人类将遭受危险而袖手旁观.</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>首先明确一点: GPT2的工作流程很像传统语言模型, 一次只输出一个单词(token).</li>
</ul>
<blockquote>
<ul>
<li>GPT2之所以在生成式任务中表现优秀, 是因为在每个新单词(token)产生后, 该单词就被添加在之前生成的单词序列后面, 添加后的新序列又会成为模型下一步的新输入. 这种机制就叫做自回归(auto-regression), 如下所示:</li>
</ul>
</blockquote>
<p></p><center><img src="./index_files/picture_40.png" height="auto" width="auto"></center><p></p>
<hr>
<ul>
<li>其次明确一点: GPT2模型是一个只包含了Transformer Decoder模块的模型.</li>
</ul>
<blockquote>
<ul>
<li>
<p>和BERT模型相比, GPT2的解码器在self-attention层上有一个关键的差异: 它将后面的单词(token)遮掩掉, 而BERT是按照一定规则将单词替换成[MASK].</p>
</li>
<li>
<p>举个例子, 如果我们重点关注4号位置的单词及其前序路径, 我们可以让模型只允许注意当前计算的单词和它之前的单词, 如下图所示:</p>
</li>
</ul>
</blockquote>
<p></p><center><img src="./index_files/picture_41.png" height="auto" width="auto"></center><p></p>
<hr>
<blockquote>
<ul>
<li>注意: 能够清楚的区分BERT使用的自注意力模块(self-attention)和GPT2使用的带掩码的自注意力模块(masked self-attention)很重要! 普通的self-attention允许模型的任意一个位置看到它右侧的信息(下图左侧), 而带掩码的self-attention则不允许这么做(下图右侧).</li>
</ul>
</blockquote>
<p></p><center><img src="./index_files/picture_42.png" height="auto" width="auto"></center><p></p>
<hr>
<blockquote>
<ul>
<li>在Transformer原始论文发表后, 一篇名为&lt;&lt; Generating Wikipedia by Summarizing Long Sequences &gt;&gt;的论文提出用另一种Transformer模块的排列方式来进行语言建模-它直接扔掉了编码器, 只保留解码器. 这个早期的基于Transformer的模型由6个Decoder Block堆叠而成:</li>
</ul>
</blockquote>
<p></p><center><img src="./index_files/picture_43.png" height="auto" width="auto"></center><p></p>
<hr>
<blockquote>
<ul>
<li>
<p>上图中所有的解码器模块都是一样的, 因为只展开了第一个解码器的内部结构. 和GPT一样, 只保留了带掩码的self-attention子层, 和Feed Forward子层.</p>
</li>
<li>
<p>这些解码器和经典Transformer原始论文中的解码器模块相比, 除了删除了第二个Encoder-Decoder Attention子层外, 其他构造都一样.</p>
</li>
</ul>
</blockquote>
<hr>
<ul>
<li>GPT2工作细节探究.<ul>
<li>GPT2可以处理最长1024个单词的序列.</li>
<li>每个单词都会和它的前序路径一起"流经"所有的解码器模块.</li>
</ul>
</li>
</ul>
<hr>
<blockquote>
<ul>
<li>
<p>对于生成式模型来说, 基本工作方式都是提供一个预先定义好的起始token, 比如记做"s".</p>
</li>
<li>
<p>此时模型的输入只有一个单词, 所以只有这个单词的路径是活跃的. 单词经过层层处理, 最终得到一个词向量. 该向量可以对于词汇表的每个单词计算出一个概率(GPT2的词汇表中有50000个单词). 在本例中, 我们选择概率最高的单词["The"]作为下一个单词.</p>
</li>
<li>
<p>注意: 这种选择最高概率输出的策略有时会出现问题-如果我们持续点击输入法推荐单词的第一个, 它可能会陷入推荐同一个词的循环中, 只有你点击第二个或第三个推荐词, 才能跳出这种循环. 同理, GPT2有一个top-k参数, 模型会从概率最大的前k个单词中抽样选取下一个单词.</p>
</li>
</ul>
</blockquote>
<p></p><center><img src="./index_files/picture_44.png" height="auto" width="auto"></center><p></p>
<hr>
<blockquote>
<ul>
<li>接下来, 我们将输出的单词["The"]添加在输入序列的尾部, 从而构建出新的输入序列["s", "The"], 让模型进行下一步的预测:</li>
</ul>
</blockquote>
<p></p><center><img src="./index_files/picture_45.png" height="auto" width="auto"></center><p></p>
<hr>
<blockquote>
<ul>
<li>此时第二个单词的路径是当前唯一活跃的路径了. GPT2的每一层都保留了它们对第一个单词的解释, 并且将运用这些信息处理第二个单词, GPT2不会根据第二个单词重新来解释第一个单词.</li>
</ul>
</blockquote>
<hr>
<ul>
<li>关于输入编码: 当我们更加深入的了解模型的内部细节时, 最开始就要面对模型的输入, 和其他自然语言模型一样, GPT2同样从嵌入矩阵中查找单词对应的嵌入向量, 该矩阵(embedding matrix)也是整个模型训练结果的一部分.</li>
</ul>
<p></p><center><img src="./index_files/picture_48.png" height="auto" width="auto"></center><p></p>
<hr>
<blockquote>
<ul>
<li>1: 如上图所示, 每一行都是一个词嵌入向量: 一个能够表征某个单词, 并捕获其语义的数字向量. 嵌入的维度大小和GPT2模型的大小相关, 最小的模型采用了768这个维度, 最大的采用了1600这个维度.</li>
</ul>
</blockquote>
<hr>
<blockquote>
<ul>
<li>2: 所以在整个模型运作起来的最开始, 我们需要在嵌入矩阵中查找起始单词"s"对应的嵌入向量. 但在将其输入给模型之前, 还需要引入位置编码(positional encoding), 1024分输入序列位置中的每一个都对应了一个位置编码, 同理于词嵌入矩阵, 这些位置编码组成的矩阵也是整个模型训练结果的一部分.</li>
</ul>
</blockquote>
<p></p><center><img src="./index_files/picture_49.png" height="auto" width="auto"></center><p></p>
<hr>
<blockquote>
<ul>
<li>经历前面的1, 2两步, 输入单词在进入模型第一个transformer模块前的所有处理步骤就结束了. 综上所述, GPT2模型包含两个权值矩阵: 词嵌入矩阵和位置编码矩阵. 而输入到transformer模块中的张量就是这两个矩阵对应的加和结果.</li>
</ul>
</blockquote>
<p></p><center><img src="./index_files/picture_46.png" height="auto" width="auto"></center><p></p>
<hr>
<ul>
<li>transformer模块的堆叠:<ul>
<li>最底层的transformer模块处理单词的步骤:<ul>
<li>首先通过自注意力层处理, 接着将其传递给前馈全连接层, 这其中包含残差连接和Layer Norm等子层操作.</li>
<li>最底层的transformer模块处理结束后, 会将结果张量传递给第二层的transformer模块, 继续进行计算.</li>
<li>每一个transformer模块的处理方式都是一样的, 不断的重复相同的模式, 但是每个模块都会维护自己的self-attention层和Feed Forward层的权重值.</li>
</ul>
</li>
</ul>
</li>
</ul>
<p></p><center><img src="./index_files/picture_47.png" height="auto" width="auto"></center><p></p>
<hr>
<ul>
<li>GPT2的自注意力机制回顾<ul>
<li>自然语言的含义是极度依赖上下文的, 比如下面所展示的"机器人第二法则":</li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li>机器人必须遵守人类给它的命令, 除非该命令违背了第一法则.</li>
</ul>
</blockquote>
<hr>
<blockquote>
<ul>
<li>
<p>在上述语句中, 有三处单词具有指代含义, 除非我们知道这些词所精确指代的上下文, 否则根本不可能理解这句话的真实语义. </p>
</li>
<li>
<p>当模型处理这句话的时候, 模型必须知道以下三点:</p>
</li>
<li>
<p>[它]指代机器人.</p>
</li>
<li>
<p>[命令]指代前半句话中人类给机器人下达的命令, 即[人类给它的命令].</p>
</li>
<li>
<p>[第一法则]指代机器人第一法则的完整内容.</p>
</li>
</ul>
</blockquote>
<hr>
<blockquote>
<ul>
<li>这就是自注意力机制所做的工作, 它在处理每个单词之前, 融入了模型对于用来解释某个单词的上下文的相关单词的理解. 具体的做法是: 给序列中的每一个单词都赋予一个相关度得分, 本质上就是注意力权重.</li>
</ul>
</blockquote>
<hr>
<blockquote>
<ul>
<li>看下图, 举个例子, 最上层的transformer模块在处理单词"it"的时候会关注"a robot", 所以"a", "robot", "it", 这三个单词与其得分相乘加权求和后的特征向量会被送入之后的Feed Forward层.</li>
</ul>
</blockquote>
<p></p><center><img src="./index_files/picture_50.png" height="auto" width="auto"></center><p></p>
<hr>
<blockquote>
<ul>
<li>
<p>自注意力机制沿着序列的每一个单词的路径进行处理, 主要由3个向量组成:</p>
</li>
<li>
<p>1: Query(查询向量), 当前单词的查询向量被用来和其它单词的键向量相乘, 从而得到其它词相对于当前词的注意力得分.</p>
</li>
<li>
<p>2: Key(键向量), 键向量就像是序列中每个单词的标签, 它使我们搜索相关单词时用来匹配的对象.</p>
</li>
<li>
<p>3: Value(值向量), 值向量是单词真正的表征, 当我们算出注意力得分后, 使用值向量进行加权求和得到能代表当前位置上下文的向量.</p>
</li>
</ul>
</blockquote>
<p></p><center><img src="./index_files/picture_51.png" height="auto" width="auto"></center><p></p>
<hr>
<blockquote>
<ul>
<li>
<p>如上图所示, 一个简单的比喻是在档案柜中找文件. 查询向量Query就像一张便利贴, 上面写着你正在研究的课题. 键向量Key像是档案柜中文件夹上贴的标签. 当你找到和便利贴上所写相匹配的文件夹时, 拿出对应的文件夹, 文件夹里的东西便是值向量Value.</p>
</li>
<li>
<p>将单词的查询向量Query分别乘以每个文件夹的键向量Key，得到各个文件夹对应的注意力得分Score.</p>
</li>
</ul>
</blockquote>
<p></p><center><img src="./index_files/picture_52.png" height="auto" width="auto"></center><p></p>
<hr>
<blockquote>
<ul>
<li>我们将每个文件夹的值向量Value乘以其对应的注意力得分Score, 然后求和, 得到最终自注意力层的输出, 如下图所示:</li>
</ul>
</blockquote>
<p></p><center><img src="./index_files/picture_53.png" height="auto" width="auto"></center><p></p>
<hr>
<blockquote>
<ul>
<li>这样将值向量加权混合得到的结果也是一个向量, 它将其50%的注意力放在了单词"robot"上, 30%的注意力放在了"a"上, 还有19%的注意力放在了"it"上.</li>
</ul>
</blockquote>
<hr>
<ul>
<li>模型的输出:</li>
</ul>
<blockquote>
<ul>
<li>当最后一个transformer模块产生输出之后, 模型会将输出张量乘上词嵌入矩阵:</li>
</ul>
</blockquote>
<p></p><center><img src="./index_files/picture_54.png" height="auto" width="auto"></center><p></p>
<hr>
<blockquote>
<ul>
<li>我们知道, 词嵌入矩阵的每一行都对应模型的词汇表中一个单词的嵌入向量. 所以这个乘法操作得到的结果就是词汇表中每个单词对应的注意力得分, 如下图所示:</li>
</ul>
</blockquote>
<p></p><center><img src="./index_files/picture_55.png" height="auto" width="auto"></center><p></p>
<hr>
<blockquote>
<ul>
<li>
<p>一般来说, 我们都采用贪心算法, 选取得分最高的单词作为输出结果(top_k = 1).</p>
</li>
<li>
<p>但是一个更好的策略是对于词汇表中得分较高的一部分单词, 将它们的得分作为概率从整个单词列表中进行抽样(得分越高的单词越容易被选中).</p>
</li>
<li>
<p>通常会用一个折中的方法, 即选取top_k = 40, 这样模型会考虑注意力得分排名前40的单词.</p>
</li>
</ul>
</blockquote>
<p></p><center><img src="./index_files/picture_56.png" height="auto" width="auto"></center><p></p>
<hr>
<blockquote>
<ul>
<li>如上图所示, 模型就完成了一个时间步的迭代, 输出了一个单词. 接下来模型会不断的迭代, 直至生成完整的序列(序列长度达到1024的上限, 或者序列的某一个时间步生成了结束符).</li>
</ul>
</blockquote>
<hr>
<h3 id="_6">小节总结</h3>
<ul>
<li>
<p>学习了GPT2的架构:</p>
<ul>
<li>GPT2只采用了Transformer架构中的Decoder模块.</li>
<li>GPT2是在GPT基础上发展处的更强大的语言预训练模型.</li>
</ul>
</li>
<li>
<p>学习了GPT2的工作细节:</p>
<ul>
<li>GPT2可以处理最长1024个单词的序列.</li>
<li>每个单词都会和它的前序路径一起"流经"所有的解码器模块.</li>
<li>GPT2本质上也是自回归模型.</li>
<li>输入张量要经历词嵌入矩阵和位置编码矩阵的加和后, 才能输入进transformer模块中.</li>
</ul>
</li>
<li>
<p>学习了GPT2自注意力机制的细节:</p>
<ul>
<li>首先, GPT2的自注意力是Masked self-attention, 只能看见左侧的序列, 不能看见右侧的信息.</li>
<li>Query, Key, Value这三个张量之间的形象化的例子, 生动的说明了各自的作用和运算方式.</li>
<li>最后的输出可以采用多个方法, 贪心方案, 概率分布方案, 或者top-k方案等.</li>
</ul>
</li>
</ul>
<hr>
<hr>
<hr>
<h2 id="24-bert-gpt-elmo">2.4 请详述BERT, GPT, ELMo模型的对比和各自的优缺点?</h2>
<hr>
<h3 id="_7">学习目标</h3>
<ul>
<li>理解BERT, GPT, ELMo相互间的不同点.</li>
<li>理解BERT, GPT, ELMo相互比较下的各自优点和缺点.</li>
</ul>
<hr>
<h3 id="bert-gpt-elmo">BERT, GPT, ELMo之间的不同点</h3>
<ul>
<li>
<p>关于特征提取器:</p>
<ul>
<li>ELMo采用两部分双层双向LSTM进行特征提取, 然后再进行特征拼接来融合语义信息.</li>
<li>GPT和BERT采用Transformer进行特征提取.</li>
<li>很多NLP任务表明Transformer的特征提取能力强于LSTM, 对于ELMo而言, 采用1层静态token embedding + 2层LSTM, 提取特征的能力有限.</li>
</ul>
</li>
<li>
<p>单/双向语言模型:</p>
<ul>
<li>三者之中, 只有GPT采用单向语言模型, 而ELMo和BERT都采用双向语言模型.</li>
<li>ELMo虽然被认为采用了双向语言模型, 但实际上是左右两个单向语言模型分别提取特征, 然后进行特征拼接, 这种融合特征的能力比BERT一体化的融合特征方式弱.</li>
<li>三者之中, 只有ELMo没有采用Transformer. GPT和BERT都源于Transformer架构, GPT的单向语言模型采用了经过修改后的Decoder模块, Decoder采用了look-ahead mask, 只能看到context before上文信息, 未来的信息都被mask掉了. 而BERT的双向语言模型采用了Encoder模块, Encoder只采用了padding mask, 可以同时看到context before上文信息, 以及context after下文信息.</li>
</ul>
</li>
</ul>
<hr>
<h3 id="bert-gpt-elmo_1">BERT, GPT, ELMo各自的优点和缺点</h3>
<ul>
<li>
<p>ELMo:</p>
<ul>
<li>优点:<ul>
<li>从早期的Word2Vec预训练模型的最大缺点出发, 进行改进, 这一缺点就是无法解决多义词的问题.</li>
<li>ELMo根据上下文动态调整word embedding, 可以解决多义词的问题.</li>
</ul>
</li>
<li>缺点:<ul>
<li>ELMo使用LSTM提取特征的能力弱于Transformer.</li>
<li>ELMo使用向量拼接的方式融合上下文特征的能力弱于Transformer.</li>
</ul>
</li>
</ul>
</li>
<li>
<p>GPT:</p>
<ul>
<li>优点:<ul>
<li>GPT使用了Transformer提取特征, 使得模型能力大幅提升.</li>
</ul>
</li>
<li>缺点:<ul>
<li>GPT只使用了单向Decoder, 无法融合未来的信息.</li>
</ul>
</li>
</ul>
</li>
<li>
<p>BERT:</p>
<ul>
<li>优点:<ul>
<li>BERT使用了双向Transformer提取特征, 使得模型能力大幅提升.</li>
<li>添加了两个预训练任务, MLM + NSP的多任务方式进行模型预训练.</li>
</ul>
</li>
<li>缺点:<ul>
<li>模型过于庞大, 参数量太多, 需要的数据和算力要求过高, 训练好的模型应用场景要求高.</li>
<li>更适合用于语言嵌入表达, 语言理解方面的任务, 不适合用于生成式的任务.</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h3 id="_8">小节总结</h3>
<ul>
<li>
<p>学习了BERT, GPT, ELMo之间的区别:</p>
<ul>
<li>
<p>三者所选取的特征提取器不同.</p>
<ul>
<li>BERT采用的是Transformer架构中的Encoder模块.</li>
<li>GPT采用的是Transformer架构中的Decoder模块.</li>
<li>ELMo采用的双层双向LSTM模块.</li>
</ul>
</li>
<li>
<p>三者所采用的语言模型单/双向不同.</p>
<ul>
<li>BERT采用的是最彻底的双向语言模型, 可以同时关注context before和context after.</li>
<li>GPT采用的是单向语言模型, 即Transformer中的Decoder, 由于采用了mask机制, 所以未来信息context after都不可见.</li>
<li>ELMo表面上被认为是双向语言模型, 但实际上是左右两个单向LSTM模型分别提取特征, 在进行简单的拼接融合.</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<hr>
<hr>
<hr>
                
                  
                
              
              
                


              
            </article>
          </div>
        </div>
      </main>
      
        
<footer class="md-footer">
  
    <div class="md-footer-nav">
      <nav class="md-footer-nav__inner md-grid">
        
          <a href="./index.html" title="1. BERT,Transformer的模型架构与详解" class="md-flex md-footer-nav__link md-footer-nav__link--prev" rel="prev">
            <div class="md-flex__cell md-flex__cell--shrink">
              <i class="md-icon md-icon--arrow-back md-footer-nav__button"></i>
            </div>
            <div class="md-flex__cell md-flex__cell--stretch md-footer-nav__title">
              <span class="md-flex__ellipsis">
                <span class="md-footer-nav__direction">
                  上一页
                </span>
                1. BERT,Transformer的模型架构与详解
              </span>
            </div>
          </a>
        
        
      </nav>
    </div>
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-footer-copyright">
        
          <div class="md-footer-copyright__highlight">
            ©Copyright 2020, AITutorials.CN This website has been reviewed by the review agency. 京ICP备19006137号
          </div>
        
        powered by
        <a href="https://www.mkdocs.org/">MkDocs</a>
        and
        <a href="https://squidfunk.github.io/mkdocs-material/">
          Material for MkDocs</a>
      </div>
      
  <div class="md-footer-social">
    <link rel="stylesheet" href="./index_files/font-awesome.css">
    
      <a href="https://www.linkedin.com/in/%E7%A7%91%E6%8A%80%E6%9C%89%E9%99%90%E5%85%AC%E5%8F%B8-%E5%8C%97%E4%BA%AC%E6%A9%98%E6%98%9F-6bb7081a1/" class="md-footer-social__link fa fa-linkedin"></a>
    
      <a href="https://weibo.com/u/3469990762?is_all=1" class="md-footer-social__link fa fa-weibo"></a>
    
      <a href="http://bitbucket.org/AITutorials" class="md-footer-social__link fa fa-bitbucket"></a>
    
      <a href="https://github.com/AITutorials/datasets/issues" class="md-footer-social__link fa fa-gitlab"></a>
    
  </div>

    </div>
  </div>
</footer>
      
    </div>
    
      <script src="./index_files/application.245445c6.js"></script>
      
        
        
          
          <script src="./index_files/lunr.stemmer.support.js"></script>
          
            
              
                <script src="./index_files/tinyseg.js"></script>
              
              
                <script src="./index_files/lunr.ja.js"></script>
              
            
          
          
        
      
      <script>app.initialize({version:"1.1.2",url:{base:".."}})</script>
      
    
  
</body></html>