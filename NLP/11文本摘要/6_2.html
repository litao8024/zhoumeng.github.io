<!DOCTYPE html>
<!-- saved from url=(0031)http://121.199.45.168:8818/6_2/ -->
<html lang="zh" class="js json svg checked target dataset details fetch supports csstransforms3d no-ios" style=""><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    
      
      <meta name="viewport" content="width=device-width,initial-scale=1">
      <meta http-equiv="x-ua-compatible" content="ie=edge">
      
      
        <link rel="canonical" href="http://0.0.0.0:8818/6_2/">
      
      
      
        <meta name="lang:clipboard.copy" content="复制">
      
        <meta name="lang:clipboard.copied" content="已复制">
      
        <meta name="lang:search.language" content="ja">
      
        <meta name="lang:search.pipeline.stopwords" content="True">
      
        <meta name="lang:search.pipeline.trimmer" content="True">
      
        <meta name="lang:search.result.none" content="没有找到符合条件的结果">
      
        <meta name="lang:search.result.one" content="找到 1 个符合条件的结果">
      
        <meta name="lang:search.result.other" content="# 个符合条件的结果">
      
        <meta name="lang:search.tokenizer" content="[\uff0c\u3002]+">
      
      <link rel="shortcut icon" href="./index_files/AI.jpg">
      <meta name="generator" content="mkdocs-1.1.2, mkdocs-material-4.4.0">
    
    
      
        <title>6.2 PGN + beam-search的优化模型 - 文本摘要项目</title>
      
    
    
      <link rel="stylesheet" href="./index_files/application.0284f74d.css">
      
      
    
    
      <script src="./index_files/modernizr.74668098.js"></script>
    
    
      
        <link href="https://fonts.gstatic.com/" rel="preconnect" crossorigin="">
        <link rel="stylesheet" href="./index_files/css">
        <style>body,input{font-family:"Roboto","Helvetica Neue",Helvetica,Arial,sans-serif}code,kbd,pre{font-family:"Roboto Mono","Courier New",Courier,monospace}</style>
      
    
    <link rel="stylesheet" href="./index_files/material-icons.css">
    
    
    
      
        
<script>
  window.ga = window.ga || function() {
    (ga.q = ga.q || []).push(arguments)
  }
  ga.l = +new Date
  /* Setup integration and send page view */
  ga("create", "UA-36723568-3", "mkdocs.org")
  ga("set", "anonymizeIp", true)
  ga("send", "pageview")
  /* Register handler to log search on blur */
  document.addEventListener("DOMContentLoaded", () => {
    if (document.forms.search) {
      var query = document.forms.search.query
      query.addEventListener("blur", function() {
        if (this.value) {
          var path = document.location.pathname;
          ga("send", "pageview", path + "?q=" + this.value)
        }
      })
    }
  })
</script>
<script async="" src="./index_files/analytics.js"></script>
      
    
    
  <script type="text/javascript">(function(){var s=document.createElement("script");var port=window.location.port;s.src="//"+window.location.hostname+":"+port+ "/livereload.js?port=" + port;document.head.appendChild(s);})();</script><script src="./index_files/livereload.js"></script></head>
  
    <body dir="ltr" data-md-state="">
  
    <svg class="md-svg">
      <defs>
        
        
          <svg xmlns="http://www.w3.org/2000/svg" width="416" height="448" viewBox="0 0 416 448" id="__github"><path fill="currentColor" d="M160 304q0 10-3.125 20.5t-10.75 19T128 352t-18.125-8.5-10.75-19T96 304t3.125-20.5 10.75-19T128 256t18.125 8.5 10.75 19T160 304zm160 0q0 10-3.125 20.5t-10.75 19T288 352t-18.125-8.5-10.75-19T256 304t3.125-20.5 10.75-19T288 256t18.125 8.5 10.75 19T320 304zm40 0q0-30-17.25-51T296 232q-10.25 0-48.75 5.25Q229.5 240 208 240t-39.25-2.75Q130.75 232 120 232q-29.5 0-46.75 21T56 304q0 22 8 38.375t20.25 25.75 30.5 15 35 7.375 37.25 1.75h42q20.5 0 37.25-1.75t35-7.375 30.5-15 20.25-25.75T360 304zm56-44q0 51.75-15.25 82.75-9.5 19.25-26.375 33.25t-35.25 21.5-42.5 11.875-42.875 5.5T212 416q-19.5 0-35.5-.75t-36.875-3.125-38.125-7.5-34.25-12.875T37 371.5t-21.5-28.75Q0 312 0 260q0-59.25 34-99-6.75-20.5-6.75-42.5 0-29 12.75-54.5 27 0 47.5 9.875t47.25 30.875Q171.5 96 212 96q37 0 70 8 26.25-20.5 46.75-30.25T376 64q12.75 25.5 12.75 54.5 0 21.75-6.75 42 34 40 34 99.5z"></path></svg>
        
      </defs>
    </svg>
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" data-md-component="overlay" for="__drawer"></label>
    
      <a href="#baseline-3" tabindex="1" class="md-skip">
        跳转至
      </a>
    
    
      <header class="md-header" data-md-component="header" data-md-state="shadow">
  <nav class="md-header-nav md-grid">
    <div class="md-flex">
      <div class="md-flex__cell md-flex__cell--shrink">
        <a href="./1_1.html" title="文本摘要项目" class="md-header-nav__button md-logo">
          
            <img src="./index_files/AI.jpg" width="24" height="24">
          
        </a>
      </div>
      <div class="md-flex__cell md-flex__cell--shrink">
        <label class="md-icon md-icon--menu md-header-nav__button" for="__drawer"></label>
      </div>
      <div class="md-flex__cell md-flex__cell--stretch">
        <div class="md-flex__ellipsis md-header-nav__title" data-md-component="title">
          
            <span class="md-header-nav__topic" style="width: 648px;">
              文本摘要项目
            </span>
            <span class="md-header-nav__topic" style="width: 648px;">
              
                6.2 PGN + beam-search的优化模型
              
            </span>
          
        </div>
      </div>
      <div class="md-flex__cell md-flex__cell--shrink">
        
          <label class="md-icon md-icon--search md-header-nav__button" for="__search"></label>
          
<div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" placeholder="搜索" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="query" data-md-state="active">
      <label class="md-icon md-search__icon" for="__search"></label>
      <button type="reset" class="md-icon md-search__icon" data-md-component="reset" tabindex="-1">
        
      </button>
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix="">
        <div class="md-search-result" data-md-component="result">
          <div class="md-search-result__meta">
            键入以开始搜索
          </div>
          <ol class="md-search-result__list"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
        
      </div>
      
        <div class="md-flex__cell md-flex__cell--shrink">
          <div class="md-header-nav__source">
            


  

<a href="https://github.com/AITutorials/manuals" title="前往 Github 仓库" class="md-source" data-md-source="github" data-md-state="done">
  
    <div class="md-source__icon">
      <svg viewBox="0 0 24 24" width="24" height="24">
        <use xlink:href="#__github" width="24" height="24"></use>
      </svg>
    </div>
  
  <div class="md-source__repository">
    Github
  </div>
</a>
          </div>
        </div>
      
    </div>
  </nav>
</header>
    
    <div class="md-container">
      
        
      
      
      <main class="md-main">
        <div class="md-main__inner md-grid" data-md-component="container">
          
            
              <div class="md-sidebar md-sidebar--primary" data-md-component="navigation" style="height: 509px;">
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    <nav class="md-nav md-nav--primary" data-md-level="0">
  <label class="md-nav__title md-nav__title--site" for="__drawer">
    <a href="./1_1.html" title="文本摘要项目" class="md-nav__button md-logo">
      
        <img src="./index_files/AI.jpg" width="48" height="48">
      
    </a>
    文本摘要项目
  </label>
  
    <div class="md-nav__source">
      


  

<a href="https://github.com/AITutorials/manuals" title="前往 Github 仓库" class="md-source" data-md-source="github" data-md-state="done">
  
    <div class="md-source__icon">
      <svg viewBox="0 0 24 24" width="24" height="24">
        <use xlink:href="#__github" width="24" height="24"></use>
      </svg>
    </div>
  
  <div class="md-source__repository">
    Github
  </div>
</a>
    </div>
  
  <ul class="md-nav__list" data-md-scrollfix="">
    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-1" type="checkbox" id="nav-1">
    
    <label class="md-nav__link" for="nav-1">
      第一章:文本摘要项目简介
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="1" style="display: none; overflow: hidden;">
      <label class="md-nav__title" for="nav-1">
        第一章:文本摘要项目简介
      </label>
      <ul class="md-nav__list" data-md-scrollfix="">
        
        
          
          
          


  <li class="md-nav__item">
    <a href="./1_1.html" title="1.1 项目背景介绍" class="md-nav__link">
      1.1 项目背景介绍
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="./1_2.html" title="1.2 项目中的数据集初探" class="md-nav__link">
      1.2 项目中的数据集初探
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-2" type="checkbox" id="nav-2">
    
    <label class="md-nav__link" for="nav-2">
      第二章:TextRank模型
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="1" style="display: none; overflow: hidden;">
      <label class="md-nav__title" for="nav-2">
        第二章:TextRank模型
      </label>
      <ul class="md-nav__list" data-md-scrollfix="">
        
        
          
          
          


  <li class="md-nav__item">
    <a href="./2_1.html" title="2.1 TextRank算法理论基础" class="md-nav__link">
      2.1 TextRank算法理论基础
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="./2_2.html" title="2.2 TextRank实现baseline-0模型" class="md-nav__link">
      2.2 TextRank实现baseline-0模型
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-3" type="checkbox" id="nav-3">
    
    <label class="md-nav__link" for="nav-3">
      第三章:seq2seq经典架构
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="1" style="display: none; overflow: hidden;">
      <label class="md-nav__title" for="nav-3">
        第三章:seq2seq经典架构
      </label>
      <ul class="md-nav__list" data-md-scrollfix="">
        
        
          
          
          


  <li class="md-nav__item">
    <a href="./3_1.html" title="3.1 seq2seq实现baseline-1模型" class="md-nav__link">
      3.1 seq2seq实现baseline-1模型
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="./3_2.html" title="3.2 baseline-1模型的优化" class="md-nav__link">
      3.2 baseline-1模型的优化
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-4" type="checkbox" id="nav-4">
    
    <label class="md-nav__link" for="nav-4">
      第四章:PGN先进架构
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="1" style="display: none; overflow: hidden;">
      <label class="md-nav__title" for="nav-4">
        第四章:PGN先进架构
      </label>
      <ul class="md-nav__list" data-md-scrollfix="">
        
        
          
          
          


  <li class="md-nav__item">
    <a href="./4_1.html" title="4.1 PGN架构解析" class="md-nav__link">
      4.1 PGN架构解析
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="./4_2.html" title="4.2 PGN模型的数据处理" class="md-nav__link">
      4.2 PGN模型的数据处理
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="./4_3.html" title="4.3 PGN实现baseline-2模型" class="md-nav__link">
      4.3 PGN实现baseline-2模型
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-5" type="checkbox" id="nav-5">
    
    <label class="md-nav__link" for="nav-5">
      第五章:生成式模型的评估方法
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="1" style="display: none; overflow: hidden;">
      <label class="md-nav__title" for="nav-5">
        第五章:生成式模型的评估方法
      </label>
      <ul class="md-nav__list" data-md-scrollfix="">
        
        
          
          
          


  <li class="md-nav__item">
    <a href="./5_1.html" title="5.1 文本摘要评估方法" class="md-nav__link">
      5.1 文本摘要评估方法
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="./5_2.html" title="5.2 ROUGE评估算法实现" class="md-nav__link">
      5.2 ROUGE评估算法实现
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      

  


  <li class="md-nav__item md-nav__item--active md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-6" type="checkbox" id="nav-6" checked="">
    
    <label class="md-nav__link" for="nav-6">
      第六章:模型的迭代优化
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="1" style="display: block; overflow: visible;">
      <label class="md-nav__title" for="nav-6">
        第六章:模型的迭代优化
      </label>
      <ul class="md-nav__list" data-md-scrollfix="">
        
        
          
          
          


  <li class="md-nav__item">
    <a href="./6_1.html" title="6.1 PGN + coverage的优化模型" class="md-nav__link">
      6.1 PGN + coverage的优化模型
    </a>
  </li>

        
          
          
          

  


  <li class="md-nav__item md-nav__item--active">
    
    <input class="md-toggle md-nav__toggle" data-md-toggle="toc" type="checkbox" id="__toc">
    
    
      <label class="md-nav__link md-nav__link--active" for="__toc">
        6.2 PGN + beam-search的优化模型
      </label>
    
    <a href="" title="6.2 PGN + beam-search的优化模型" class="md-nav__link md-nav__link--active">
      6.2 PGN + beam-search的优化模型
    </a>
    
      
<nav class="md-nav md-nav--secondary">
  
  
  
    <label class="md-nav__title" for="__toc">目录</label>
    <ul class="md-nav__list" data-md-scrollfix="">
      
        <li class="md-nav__item">
  <a href="#baseline-3" title="对baseline-3模型的优化" class="md-nav__link">
    对baseline-3模型的优化
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_1" title="学习目标" class="md-nav__link">
    学习目标
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#beam-search" title="Beam-search算法" class="md-nav__link">
    Beam-search算法
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#beam-search_1" title="Beam-search算法的概念" class="md-nav__link">
    Beam-search算法的概念
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_2" title="常用解码算法的分析" class="md-nav__link">
    常用解码算法的分析
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#beam-searchbaseline-4" title="Beam-search实现baseline-4模型" class="md-nav__link">
    Beam-search实现baseline-4模型
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#beam-search_2" title="第一步: 添加Beam-search的配置信息" class="md-nav__link">
    第一步: 添加Beam-search的配置信息
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#beam" title="第二步: 工具函数中实现Beam类" class="md-nav__link">
    第二步: 工具函数中实现Beam类
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#predictbeam-search" title="第三步: 预测类Predict中添加Beam-search代码逻辑" class="md-nav__link">
    第三步: 预测类Predict中添加Beam-search代码逻辑
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#rougebaseline-4" title="利用ROUGE评估baseline-4模型" class="md-nav__link">
    利用ROUGE评估baseline-4模型
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#pgnbaseline-4" title="对PGN的baseline-4模型进行评估" class="md-nav__link">
    对PGN的baseline-4模型进行评估
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#rouge" title="ROUGE评估结果对比" class="md-nav__link">
    ROUGE评估结果对比
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_3" title="小节总结" class="md-nav__link">
    小节总结
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
      
      
      
      
    </ul>
  
</nav>
    
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="./6_3.html" title="6.3 数据增强的优化" class="md-nav__link">
      6.3 数据增强的优化
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="./6_4.html" title="6.4 训练策略的优化" class="md-nav__link">
      6.4 训练策略的优化
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-7" type="checkbox" id="nav-7">
    
    <label class="md-nav__link" for="nav-7">
      第七章:模型的部署与总结
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="1" style="display: none; overflow: hidden;">
      <label class="md-nav__title" for="nav-7">
        第七章:模型的部署与总结
      </label>
      <ul class="md-nav__list" data-md-scrollfix="">
        
        
          
          
          


  <li class="md-nav__item">
    <a href="./7_1.html" title="7.1 硬件优化与模型部署" class="md-nav__link">
      7.1 硬件优化与模型部署
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="./7_2.html" title="7.2 项目总结" class="md-nav__link">
      7.2 项目总结
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              <div class="md-sidebar md-sidebar--secondary" data-md-component="toc" style="height: 509px;">
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    
<nav class="md-nav md-nav--secondary">
  
  
  
    <label class="md-nav__title" for="__toc">目录</label>
    <ul class="md-nav__list" data-md-scrollfix="">
      
        <li class="md-nav__item">
  <a href="#baseline-3" title="对baseline-3模型的优化" class="md-nav__link">
    对baseline-3模型的优化
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_1" title="学习目标" class="md-nav__link">
    学习目标
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#beam-search" title="Beam-search算法" class="md-nav__link">
    Beam-search算法
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#beam-search_1" title="Beam-search算法的概念" class="md-nav__link">
    Beam-search算法的概念
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_2" title="常用解码算法的分析" class="md-nav__link">
    常用解码算法的分析
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#beam-searchbaseline-4" title="Beam-search实现baseline-4模型" class="md-nav__link">
    Beam-search实现baseline-4模型
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#beam-search_2" title="第一步: 添加Beam-search的配置信息" class="md-nav__link">
    第一步: 添加Beam-search的配置信息
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#beam" title="第二步: 工具函数中实现Beam类" class="md-nav__link">
    第二步: 工具函数中实现Beam类
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#predictbeam-search" title="第三步: 预测类Predict中添加Beam-search代码逻辑" class="md-nav__link">
    第三步: 预测类Predict中添加Beam-search代码逻辑
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#rougebaseline-4" title="利用ROUGE评估baseline-4模型" class="md-nav__link">
    利用ROUGE评估baseline-4模型
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#pgnbaseline-4" title="对PGN的baseline-4模型进行评估" class="md-nav__link">
    对PGN的baseline-4模型进行评估
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#rouge" title="ROUGE评估结果对比" class="md-nav__link">
    ROUGE评估结果对比
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_3" title="小节总结" class="md-nav__link">
    小节总结
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
      
      
      
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          <div class="md-content">
            <article class="md-content__inner md-typeset">
              
                
                
                  <h1>6.2 PGN + beam-search的优化模型</h1>
                
                <h2 id="baseline-3">对baseline-3模型的优化</h2>
<hr>
<h3 id="_1">学习目标</h3>
<ul>
<li>理解为什么要采用Beam-search的原因.</li>
<li>掌握Beam-search算法的概念和实现.</li>
<li>掌握利用Beam-search来优化文本摘要模型.</li>
</ul>
<hr>
<h3 id="beam-search">Beam-search算法</h3>
<h4 id="beam-search_1">Beam-search算法的概念</h4>
<ul>
<li>我们已经有了4个模型, 分别是TextRank, seq2seq, PGN + attention, 和PGN + attention + coverage. 这些优化的方法可以归结为两类:<ul>
<li>第一类: 模型架构的优化.</li>
<li>第二类: 模型训练算法的优化.</li>
</ul>
</li>
</ul>
<hr>
<blockquote>
<ul>
<li>那么除了上述的两大类, 思考一个问题: 我们是否可以从模型的预测算法入手呢?</li>
</ul>
</blockquote>
<hr>
<ul>
<li>当然可以! 回顾一下我们在baseline-1到baseline-3的全部解码过程, 采用的都是贪心算法! 只要在这个算法上进行优化, 就可以提升模型预测的能力!</li>
</ul>
<hr>
<ul>
<li>Greedy Decode的缺陷: 每一个时间步的解码, 都是选取当前神经网络输出层中"最大值"作为解码结果. 这种方式很显然并不是最优解, 只是简单易用, 算法效率高. 知道了贪心解码的缺陷所在, 就可以针对性的提出解决方案了.<ul>
<li>第一种: 考虑所有的解码可能, 从中挑选最优路径.</li>
<li>第二种: 考虑折中的解码可能, 从中挑选最优路径.</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>
<p>第一种方案时间复杂度太高, 是指数式的复杂度, 显然无法实际应用.</p>
</li>
<li>
<p>第二种方案可行性高, 比如采用每个时间步考虑TOP2, 或TOP3, 然后再在这个基础上搜索下一个时间步的解码方案.</p>
</li>
</ul>
<hr>
<ul>
<li>Beam-search的概念: 在当前级别的状态下计算所有可能性, 并按照递增顺序对它们进行排序, 但只保留一定数量的可能结果(依据beam_size决定这个数量), 接着根据这些可能的结果进行扩展, 迭代以上动作直到搜索结束并返回最高概率的解.</li>
</ul>
<hr>
<ul>
<li>Beam-search算法示例: 假设词表大小为3, 包含单词为[A, B, C], 设置beam_size等于2.<ul>
<li>第一步: 生成第1个词的时候, 对P(A), P(B), P(C)进行排序, 并选取概率最大的两个, 假设为单词A, C.</li>
<li>第二步: 生成第2个词的时候, 将当前序列A, C分别和词表中的所有词进行组合, 得到新的6个组合序列AA, AB, AC, CA, CB, CC, 并选取概率最大的两个, 假设为AA, CC.</li>
<li>第三步: 继续在第二步AA, AC的基础上重复第二步的过程, 直到遇见结束符为止, 最终输出2个得分最高的序列就是我们在beam_size=2的条件下得到的解码结果.</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>有了上面文字描述的示例, 我们再通过图解更清晰, 形象的理解一下Beam-search算法:<ul>
<li>从开始符<start>出发, 每次解码后选取TOP2概率的结果保留下来, 第一步后留下he, I.</start></li>
<li>第二步从he出发, 保留TOP2得到hit, struck; 从I出发, 保留TOP2得到was, got.</li>
<li>那么目前已经有4个结果序列了, 依然选取TOP2的序列作为第三步的基础序列, 明显最大概率的两个是-1.6和-1.7对应的序列, 也就是<start> he hit, 和<start> I was.</start></start></li>
</ul>
</li>
</ul>
<hr>
<p></p><center><img alt="" src="./index_files/33.png"></center><p></p>
<hr>
<ul>
<li>接下来就是迭代进行前面的过程, 计算-选取TOP2-保留基础序列结果-再计算, 最终下图中绿色的序列就是采用Beam-search算法下的解码结果.</li>
</ul>
<hr>
<p></p><center><img alt="" src="./index_files/34.png"></center><p></p>
<hr>
<hr>
<h4 id="_2">常用解码算法的分析</h4>
<ul>
<li>在预测阶段, 对于生成式任务, 我们可以理解为解码阶段, 目前学习了三种:<ul>
<li>Greedy Decode(贪心解码)</li>
<li>Viterbi Decode(维特比解码)</li>
<li>Beam-search Decode(集束解码)</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>Greedy Decode(贪心解码):<ul>
<li>最普遍的解码方式, 效率最高, 简单易懂</li>
<li>无法保证结果最佳, 更无法保证得到最优解.</li>
<li>时间复杂度O(T * N)</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>Viterbi Decode(维特比解码):<ul>
<li>尤其对于离线算法应用较广, 效率较低, 理解上有难度.</li>
<li>Viterbi属于动态规划算法, 保证得到最优解.</li>
<li>时间复杂度O(T * N * N)</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>Beam-search Decode(集束解码):<ul>
<li>属于贪心解码的优化算法, 效率较高, 较易理解.</li>
<li>无法保证得到最优解, 但是一个相对较好的局部最优解在工程时间上可以接收.</li>
<li>时间复杂度O(T * K * N), beam_size=K.</li>
</ul>
</li>
</ul>
<hr>
<hr>
<h3 id="beam-searchbaseline-4">Beam-search实现baseline-4模型</h3>
<ul>
<li>要实现Beam-search策略的baseline-4模型, 需要以下三个步骤:<ul>
<li>第一步: 添加Beam-search的配置信息.</li>
<li>第二步: 工具函数中实现Beam类.</li>
<li>第三步: 预测类Predict中添加Beam-search代码逻辑.</li>
</ul>
</li>
</ul>
<hr>
<h4 id="beam-search_2">第一步: 添加Beam-search的配置信息</h4>
<ul>
<li>这些配置信息需要追加进config.py配置文件中:<ul>
<li>代码文件地址: /home/ec2-user/text_summary/pgn/utils/config.py</li>
</ul>
</li>
</ul>
<hr>
<div class="codehilite" id="__code_0"><button class="md-clipboard" title="复制" data-clipboard-target="#__code_0 pre, #__code_0 code"><span class="md-clipboard__message"></span></button><pre id="__code_1"><span></span><button class="md-clipboard" title="复制" data-clipboard-target="#__code_1 pre, #__code_1 code"><span class="md-clipboard__message"></span></button><code><span class="c1"># Beam search相关配置信息</span>
<span class="n">beam_size</span> <span class="o">=</span> <span class="mi">3</span>
<span class="n">alpha</span> <span class="o">=</span> <span class="mf">0.2</span>
<span class="n">beta</span> <span class="o">=</span> <span class="mf">0.2</span>
<span class="n">gamma</span> <span class="o">=</span> <span class="mi">2000</span>
</code></pre></div>


<hr>
<h4 id="beam">第二步: 工具函数中实现Beam类</h4>
<ul>
<li>Beam类的代码追加进工具函数func_utils.py代码文件中:<ul>
<li>代码文件地址: /home/ec2-user/text_summary/pgn/utils/func_utils.py</li>
</ul>
</li>
</ul>
<hr>
<div class="codehilite" id="__code_2"><button class="md-clipboard" title="复制" data-clipboard-target="#__code_2 pre, #__code_2 code"><span class="md-clipboard__message"></span></button><pre id="__code_3"><span></span><button class="md-clipboard" title="复制" data-clipboard-target="#__code_3 pre, #__code_3 code"><span class="md-clipboard__message"></span></button><code><span class="c1"># 构建Beam-search的基础类</span>
<span class="k">class</span> <span class="nc">Beam</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tokens</span><span class="p">,</span> <span class="n">log_probs</span><span class="p">,</span> <span class="n">decoder_states</span><span class="p">,</span> <span class="n">coverage_vector</span><span class="p">):</span>
        <span class="c1"># Beam类所需的4个参数</span>
        <span class="c1"># tokens: 已经搜索到的字符序列</span>
        <span class="c1"># log_probs: 已经搜索的字符序列的得分序列</span>
        <span class="c1"># decoder_states: Decoder解码器端的隐藏层状态张量</span>
        <span class="c1"># coverage_vector: 引入coverage机制后计算得到的coverage张量</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tokens</span> <span class="o">=</span> <span class="n">tokens</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log_probs</span> <span class="o">=</span> <span class="n">log_probs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">decoder_states</span> <span class="o">=</span> <span class="n">decoder_states</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">coverage_vector</span> <span class="o">=</span> <span class="n">coverage_vector</span>

    <span class="c1"># 非常重要的扩展函数, 当前搜索序列向前进一步, 添加当前搜索的字符token和分数log_probs</span>
    <span class="k">def</span> <span class="nf">extend</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">token</span><span class="p">,</span> <span class="n">log_prob</span><span class="p">,</span> <span class="n">decoder_states</span><span class="p">,</span> <span class="n">coverage_vector</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Beam</span><span class="p">(</span><span class="n">tokens</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">tokens</span> <span class="o">+</span> <span class="p">[</span><span class="n">token</span><span class="p">],</span>
                    <span class="n">log_probs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">log_probs</span> <span class="o">+</span> <span class="p">[</span><span class="n">log_prob</span><span class="p">],</span>
                    <span class="n">decoder_states</span><span class="o">=</span><span class="n">decoder_states</span><span class="p">,</span>
                    <span class="n">coverage_vector</span><span class="o">=</span><span class="n">coverage_vector</span><span class="p">)</span>

    <span class="c1"># 计算当前序列得分的函数</span>
    <span class="k">def</span> <span class="nf">seq_score</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># 得到当前序列的长度, 用来计算正则化参数</span>
        <span class="n">len_Y</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tokens</span><span class="p">)</span>
        <span class="c1"># 序列长度的正则化, 自定义公式</span>
        <span class="n">ln</span> <span class="o">=</span> <span class="p">(</span><span class="mi">5</span> <span class="o">+</span> <span class="n">len_Y</span><span class="p">)</span><span class="o">**</span><span class="n">config</span><span class="o">.</span><span class="n">alpha</span> <span class="o">/</span> <span class="p">(</span><span class="mi">5</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span><span class="o">**</span><span class="n">config</span><span class="o">.</span><span class="n">alpha</span>
        <span class="c1"># coverage张量的正则化计算, 固定公式计算即可</span>
        <span class="n">cn</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">beta</span> <span class="o">*</span> <span class="n">torch</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">config</span><span class="o">.</span><span class="n">eps</span> <span class="o">+</span> <span class="n">torch</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coverage_vector</span> <span class="o">&lt;</span> <span class="mf">1.0</span><span class="p">,</span>
                                                                        <span class="bp">self</span><span class="o">.</span><span class="n">coverage_vector</span><span class="p">,</span>
                           <span class="n">torch</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">coverage_vector</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">device</span><span class="p">(</span><span class="n">config</span><span class="o">.</span><span class="n">DEVICE</span><span class="p">)))))</span>

        <span class="c1"># 直接利用上面的正则化参数, 计算当前序列的分数即可</span>
        <span class="n">score</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">log_probs</span><span class="p">)</span> <span class="o">/</span> <span class="n">ln</span> <span class="o">+</span> <span class="n">cn</span>
        <span class="k">return</span> <span class="n">score</span>

    <span class="c1"># 比较序列分数的小于&lt;关系</span>
    <span class="k">def</span> <span class="fm">__lt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">seq_score</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">other</span><span class="o">.</span><span class="n">seq_score</span><span class="p">()</span>

    <span class="c1"># 比较序列分数的小于等于&lt;=关系</span>
    <span class="k">def</span> <span class="fm">__le__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">seq_score</span><span class="p">()</span> <span class="o">&lt;=</span> <span class="n">other</span><span class="o">.</span><span class="n">seq_score</span><span class="p">()</span>
</code></pre></div>


<hr>
<ul>
<li>还要添加一个函数, 也在func_utils.py文件中添加:</li>
</ul>
<div class="codehilite" id="__code_4"><button class="md-clipboard" title="复制" data-clipboard-target="#__code_4 pre, #__code_4 code"><span class="md-clipboard__message"></span></button><pre id="__code_5"><span></span><button class="md-clipboard" title="复制" data-clipboard-target="#__code_5 pre, #__code_5 code"><span class="md-clipboard__message"></span></button><code><span class="c1"># 本函数的作用是维护一个小顶堆, 拥有k个节点的二叉树结构, 最小值始终保持在堆顶!</span>
<span class="k">def</span> <span class="nf">add2heap</span><span class="p">(</span><span class="n">heap</span><span class="p">,</span> <span class="n">item</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
    <span class="c1"># 如果当前堆的元素个数小于k, 则添加新节元素item为一个新的节点, 同时维护小顶堆的规则.</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">heap</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">k</span><span class="p">:</span>
        <span class="n">heapq</span><span class="o">.</span><span class="n">heappush</span><span class="p">(</span><span class="n">heap</span><span class="p">,</span> <span class="n">item</span><span class="p">)</span>
    <span class="c1"># 如果当前堆的元素个数不小于k, 则添加新节元素item为一个新的节点, 同时按照小顶堆的规则删除一个不符合的节点.</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">heapq</span><span class="o">.</span><span class="n">heappushpop</span><span class="p">(</span><span class="n">heap</span><span class="p">,</span> <span class="n">item</span><span class="p">)</span>
</code></pre></div>


<hr>
<h4 id="predictbeam-search">第三步: 预测类Predict中添加Beam-search代码逻辑</h4>
<ul>
<li>Beam-search相关的解码逻辑放在predict.py代码文件中:<ul>
<li>代码文件路径: /home/ec2-user/text_summary/pgn/src/predict.py</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>在编写类Predict()时, 最重要的是添加两个新的类内函数来支持beam-search的操作:<ul>
<li>def best_k(self): 利用解码器产生出一个vocab distribution, 来预测下一个token.</li>
<li>def beam_search(self): 支持beam-search解码策略的主逻辑函数.</li>
</ul>
</li>
</ul>
<div class="codehilite" id="__code_6"><button class="md-clipboard" title="复制" data-clipboard-target="#__code_6 pre, #__code_6 code"><span class="md-clipboard__message"></span></button><pre id="__code_7"><span></span><button class="md-clipboard" title="复制" data-clipboard-target="#__code_7 pre, #__code_7 code"><span class="md-clipboard__message"></span></button><code><span class="c1"># 导入相关系统工具包</span>
<span class="kn">import</span> <span class="nn">random</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">torch</span>
<span class="kn">import</span> <span class="nn">jieba</span>

<span class="c1"># 设置项目的root路径, 方便后续相关代码文件的导入</span>
<span class="n">root_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">abspath</span><span class="p">(</span><span class="vm">__file__</span><span class="p">)))</span>
<span class="n">sys</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">root_path</span><span class="p">)</span>

<span class="c1"># 导入项目的相关代码文件</span>
<span class="kn">from</span> <span class="nn">utils</span> <span class="kn">import</span> <span class="n">config</span>
<span class="kn">from</span> <span class="nn">src.model</span> <span class="kn">import</span> <span class="n">PGN</span>
<span class="kn">from</span> <span class="nn">utils.dataset</span> <span class="kn">import</span> <span class="n">PairDataset</span>
<span class="kn">from</span> <span class="nn">utils.func_utils</span> <span class="kn">import</span> <span class="n">source2ids</span><span class="p">,</span> <span class="n">outputids2words</span><span class="p">,</span> <span class="n">Beam</span><span class="p">,</span> <span class="n">timer</span><span class="p">,</span> <span class="n">add2heap</span><span class="p">,</span> <span class="n">replace_oovs</span>


<span class="c1"># 构建核心预测类Predict</span>
<span class="k">class</span> <span class="nc">Predict</span><span class="p">():</span>
    <span class="nd">@timer</span><span class="p">(</span><span class="n">module</span><span class="o">=</span><span class="s1">'initalize predicter'</span><span class="p">)</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">DEVICE</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">DEVICE</span>

        <span class="c1"># 产生数据对, 为接下来的迭代器做数据准备, 注意这里面用的是训练集数据</span>
        <span class="n">dataset</span> <span class="o">=</span> <span class="n">PairDataset</span><span class="p">(</span><span class="n">config</span><span class="o">.</span><span class="n">train_data_path</span><span class="p">,</span>
                              <span class="n">max_enc_len</span><span class="o">=</span><span class="n">config</span><span class="o">.</span><span class="n">max_enc_len</span><span class="p">,</span>
                              <span class="n">max_dec_len</span><span class="o">=</span><span class="n">config</span><span class="o">.</span><span class="n">max_dec_len</span><span class="p">,</span>
                              <span class="n">truncate_enc</span><span class="o">=</span><span class="n">config</span><span class="o">.</span><span class="n">truncate_enc</span><span class="p">,</span>
                              <span class="n">truncate_dec</span><span class="o">=</span><span class="n">config</span><span class="o">.</span><span class="n">truncate_dec</span><span class="p">)</span>

        <span class="c1"># 生成词汇表</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vocab</span> <span class="o">=</span> <span class="n">dataset</span><span class="o">.</span><span class="n">build_vocab</span><span class="p">(</span><span class="n">embed_file</span><span class="o">=</span><span class="n">config</span><span class="o">.</span><span class="n">embed_file</span><span class="p">)</span>

        <span class="c1"># 实例化PGN模型类, 这里面的模型是基于baseline-3的模型.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">model</span> <span class="o">=</span> <span class="n">PGN</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vocab</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stop_word</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">vocab</span><span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">strip</span><span class="p">()]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">open</span><span class="p">(</span><span class="n">config</span><span class="o">.</span><span class="n">stop_word_file</span><span class="p">)</span><span class="o">.</span><span class="n">readlines</span><span class="p">()]))</span>

        <span class="c1"># 将已经训练好的模型作为初始化参数load进来, 并放到GPU上.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">load_state_dict</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">config</span><span class="o">.</span><span class="n">model_save_path</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">DEVICE</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">greedy_search</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">max_sum_len</span><span class="p">,</span> <span class="n">len_oovs</span><span class="p">,</span> <span class="n">x_padding_masks</span><span class="p">):</span>
        <span class="n">encoder_output</span><span class="p">,</span> <span class="n">encoder_states</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">encoder</span><span class="p">(</span><span class="n">replace_oovs</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">vocab</span><span class="p">))</span>

        <span class="c1"># 用encoder的hidden state初始化decoder的hidden state</span>
        <span class="n">decoder_states</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">reduce_state</span><span class="p">(</span><span class="n">encoder_states</span><span class="p">)</span>

        <span class="c1"># 利用SOS作为解码器的初始化输入字符</span>
        <span class="n">x_t</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">vocab</span><span class="o">.</span><span class="n">SOS</span>
        <span class="n">x_t</span> <span class="o">=</span> <span class="n">x_t</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">DEVICE</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span>
        <span class="n">summary</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">vocab</span><span class="o">.</span><span class="n">SOS</span><span class="p">]</span>
        <span class="n">coverage_vector</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">DEVICE</span><span class="p">)</span>

        <span class="c1"># 循环解码, 最多解码max_sum_len步</span>
        <span class="k">while</span> <span class="nb">int</span><span class="p">(</span><span class="n">x_t</span><span class="o">.</span><span class="n">item</span><span class="p">())</span> <span class="o">!=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vocab</span><span class="o">.</span><span class="n">EOS</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">summary</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">max_sum_len</span><span class="p">:</span>
            <span class="n">context_vector</span><span class="p">,</span> <span class="n">attention_weights</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">attention</span><span class="p">(</span><span class="n">decoder_states</span><span class="p">,</span>
                                                                     <span class="n">encoder_output</span><span class="p">,</span>
                                                                     <span class="n">x_padding_masks</span><span class="p">,</span>
                                                                     <span class="n">coverage_vector</span><span class="p">)</span>

            <span class="n">p_vocab</span><span class="p">,</span> <span class="n">decoder_states</span><span class="p">,</span> <span class="n">p_gen</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">decoder</span><span class="p">(</span><span class="n">x_t</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span>
                                                                <span class="n">decoder_states</span><span class="p">,</span>
                                                                <span class="n">context_vector</span><span class="p">)</span>

            <span class="n">final_dist</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">get_final_distribution</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">p_gen</span><span class="p">,</span> <span class="n">p_vocab</span><span class="p">,</span>
                                                           <span class="n">attention_weights</span><span class="p">,</span>
                                                           <span class="n">torch</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">len_oovs</span><span class="p">))</span>

            <span class="c1"># 以贪心解码策略预测字符</span>
            <span class="n">x_t</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">final_dist</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">DEVICE</span><span class="p">)</span>
            <span class="n">decoder_word_idx</span> <span class="o">=</span> <span class="n">x_t</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>

            <span class="c1"># 将预测的字符添加进结果摘要中</span>
            <span class="n">summary</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">decoder_word_idx</span><span class="p">)</span>
            <span class="n">x_t</span> <span class="o">=</span> <span class="n">replace_oovs</span><span class="p">(</span><span class="n">x_t</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">vocab</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">summary</span>


    <span class="c1"># -----------------------------------------------------------------------------------------</span>
    <span class="c1"># 下面的函数best_k()和beam_search()是6.2小节新增的, 用于支持Beam-search解码的新函数.</span>

    <span class="c1"># 利用解码器产生出一个vocab distribution, 来预测下一个token.</span>
    <span class="k">def</span> <span class="nf">best_k</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">beam</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">encoder_output</span><span class="p">,</span> <span class="n">x_padding_masks</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">len_oovs</span><span class="p">):</span>
        <span class="c1"># beam: 代表Beam类的一个实例化对象.</span>
        <span class="c1"># k: 代表Beam-search中的重要参数beam_size=k.</span>
        <span class="c1"># encoder_output: 编码器的输出张量.</span>
        <span class="c1"># x_padding_masks: 输入序列的padding mask, 用于遮掩那些无效的PAD位置字符</span>
        <span class="c1"># x: 编码器的输入张量.</span>
        <span class="c1"># len_oovs: OOV列表的长度.</span>
        <span class="c1"># 当前时间步t的对应解析字符token, 将作为Decoder端的输入, 产生最终的vocab distribution.</span>
        <span class="n">x_t</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">beam</span><span class="o">.</span><span class="n">tokens</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">x_t</span> <span class="o">=</span> <span class="n">x_t</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">DEVICE</span><span class="p">)</span>

        <span class="c1"># 通过注意力层attention, 得到context_vector</span>
        <span class="n">context_vector</span><span class="p">,</span> <span class="n">attention_weights</span><span class="p">,</span> <span class="n">coverage_vector</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">attention</span><span class="p">(</span><span class="n">beam</span><span class="o">.</span><span class="n">decoder_states</span><span class="p">,</span>
                                                                                  <span class="n">encoder_output</span><span class="p">,</span>
                                                                                  <span class="n">x_padding_masks</span><span class="p">,</span>
                                                                                  <span class="n">beam</span><span class="o">.</span><span class="n">coverage_vector</span><span class="p">)</span>

        <span class="c1"># 函数replace_oovs()将OOV单词替换成新的id值, 来避免解码器出现index-out-of-bound error</span>
        <span class="n">p_vocab</span><span class="p">,</span> <span class="n">decoder_states</span><span class="p">,</span> <span class="n">p_gen</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">decoder</span><span class="p">(</span><span class="n">replace_oovs</span><span class="p">(</span><span class="n">x_t</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">vocab</span><span class="p">),</span>
                                                            <span class="n">beam</span><span class="o">.</span><span class="n">decoder_states</span><span class="p">,</span>
                                                            <span class="n">context_vector</span><span class="p">)</span>

        <span class="c1"># 调用PGN网络中的函数, 得到最终的单词分布(包含OOV)</span>
        <span class="n">final_dist</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">get_final_distribution</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">p_gen</span><span class="p">,</span> <span class="n">p_vocab</span><span class="p">,</span>
                                                       <span class="n">attention_weights</span><span class="p">,</span>
                                                       <span class="n">torch</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">len_oovs</span><span class="p">))</span>

        <span class="c1"># 计算序列的log_probs分数</span>
        <span class="n">log_probs</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">final_dist</span><span class="o">.</span><span class="n">squeeze</span><span class="p">())</span>
        <span class="c1"># 如果当前Beam序列只有1个token, 要将一些无效字符删除掉, 以免影响序列的计算.</span>
        <span class="c1"># 至于这个无效字符的列表都包含什么, 也是利用bad case的分析, 结合数据观察得到的, 属于调优的一部分.</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">beam</span><span class="o">.</span><span class="n">tokens</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">forbidden_ids</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">vocab</span><span class="p">[</span><span class="sa">u</span><span class="s2">"这"</span><span class="p">],</span>
                             <span class="bp">self</span><span class="o">.</span><span class="n">vocab</span><span class="p">[</span><span class="sa">u</span><span class="s2">"此"</span><span class="p">],</span>
                             <span class="bp">self</span><span class="o">.</span><span class="n">vocab</span><span class="p">[</span><span class="sa">u</span><span class="s2">"采用"</span><span class="p">],</span>
                             <span class="bp">self</span><span class="o">.</span><span class="n">vocab</span><span class="p">[</span><span class="sa">u</span><span class="s2">"，"</span><span class="p">],</span>
                             <span class="bp">self</span><span class="o">.</span><span class="n">vocab</span><span class="p">[</span><span class="sa">u</span><span class="s2">"。"</span><span class="p">]]</span>

            <span class="n">log_probs</span><span class="p">[</span><span class="n">forbidden_ids</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="nb">float</span><span class="p">(</span><span class="s1">'inf'</span><span class="p">)</span>
        <span class="c1"># 对于EOS token的一个罚分处理.</span>
        <span class="c1"># 具体做法参考了https://opennmt.net/OpenNMT/translation/beam_search/.</span>
        <span class="n">log_probs</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">vocab</span><span class="o">.</span><span class="n">EOS</span><span class="p">]</span> <span class="o">*=</span> <span class="n">config</span><span class="o">.</span><span class="n">gamma</span> <span class="o">*</span> <span class="n">x</span><span class="o">.</span><span class="n">size</span><span class="p">()[</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">beam</span><span class="o">.</span><span class="n">tokens</span><span class="p">)</span>
        <span class="n">log_probs</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">vocab</span><span class="o">.</span><span class="n">UNK</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="nb">float</span><span class="p">(</span><span class="s1">'inf'</span><span class="p">)</span>

        <span class="c1"># 从log_probs中获取top_k分数的tokens, 这也正好符合beam-search的逻辑.</span>
        <span class="n">topk_probs</span><span class="p">,</span> <span class="n">topk_idx</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">topk</span><span class="p">(</span><span class="n">log_probs</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>

        <span class="c1"># 非常关键的一行代码: 利用top_k的单词, 来扩展beam-search搜索序列, 等效于将top_k单词追加到候选序列的末尾.</span>
        <span class="n">best_k</span> <span class="o">=</span> <span class="p">[</span><span class="n">beam</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">log_probs</span><span class="p">[</span><span class="n">x</span><span class="p">],</span> <span class="n">decoder_states</span><span class="p">,</span> <span class="n">coverage_vector</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">topk_idx</span><span class="o">.</span><span class="n">tolist</span><span class="p">()]</span>

        <span class="c1"># 返回追加后的结果列表</span>
        <span class="k">return</span> <span class="n">best_k</span>


    <span class="c1"># 支持beam-search解码策略的主逻辑函数.</span>
    <span class="k">def</span> <span class="nf">beam_search</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">max_sum_len</span><span class="p">,</span> <span class="n">beam_size</span><span class="p">,</span> <span class="n">len_oovs</span><span class="p">,</span> <span class="n">x_padding_masks</span><span class="p">):</span>
        <span class="c1"># x: 编码器的输入张量, 即article(source document)</span>
        <span class="c1"># max_sum_len: 本质上就是最大解码长度max_dec_len</span>
        <span class="c1"># beam_size: 采用beam-search策略下的搜索宽度k</span>
        <span class="c1"># len_oovs: OOV列表的长度</span>
        <span class="c1"># x_padding_masks: 针对编码器的掩码张量, 把无效的PAD字符遮掩掉.</span>
        <span class="c1"># 第一步: 通过Encoder计算得到编码器的输出张量.</span>
        <span class="n">encoder_output</span><span class="p">,</span> <span class="n">encoder_states</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">encoder</span><span class="p">(</span><span class="n">replace_oovs</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">vocab</span><span class="p">))</span>

        <span class="c1"># 全零张量初始化coverage vector</span>
        <span class="n">coverage_vector</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">DEVICE</span><span class="p">)</span>
        <span class="c1"># 对encoder_states进行加和降维处理, 赋值给decoder_states.</span>
        <span class="n">decoder_states</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">reduce_state</span><span class="p">(</span><span class="n">encoder_states</span><span class="p">)</span>

        <span class="c1"># 初始化hypothesis, 第一个token给SOS, 分数给0.</span>
        <span class="n">init_beam</span> <span class="o">=</span> <span class="n">Beam</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">vocab</span><span class="o">.</span><span class="n">SOS</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">decoder_states</span><span class="p">,</span> <span class="n">coverage_vector</span><span class="p">)</span>

        <span class="c1"># beam_size本质上就是搜索宽度k</span>
        <span class="n">k</span> <span class="o">=</span> <span class="n">beam_size</span>
        <span class="c1"># 初始化curr作为当前候选集, completed作为最终的hypothesis列表</span>
        <span class="n">curr</span><span class="p">,</span> <span class="n">completed</span> <span class="o">=</span> <span class="p">[</span><span class="n">init_beam</span><span class="p">],</span> <span class="p">[]</span>

        <span class="c1"># 通过for循环连续解码max_sum_len步, 每一步应用beam-search策略产生预测token.</span>
        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">max_sum_len</span><span class="p">):</span>
            <span class="c1"># 初始化当前时间步的topk列表为空, 后续将beam-search的解码结果存储在topk中.</span>
            <span class="n">topk</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">beam</span> <span class="ow">in</span> <span class="n">curr</span><span class="p">:</span>
                <span class="c1"># 如果产生了一个EOS token, 则将beam对象追加进最终的hypothesis列表, 并将k值减1, 然后继续搜索.</span>
                <span class="k">if</span> <span class="n">beam</span><span class="o">.</span><span class="n">tokens</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">vocab</span><span class="o">.</span><span class="n">EOS</span><span class="p">:</span>
                    <span class="n">completed</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">beam</span><span class="p">)</span>
                    <span class="n">k</span> <span class="o">-=</span> <span class="mi">1</span>
                    <span class="k">continue</span>

                <span class="c1"># 遍历最好的k个候选集序列.</span>
                <span class="k">for</span> <span class="n">can</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">best_k</span><span class="p">(</span><span class="n">beam</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">encoder_output</span><span class="p">,</span> <span class="n">x_padding_masks</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">len_oovs</span><span class="p">)):</span>
                    <span class="c1"># 利用小顶堆来维护一个top_k的candidates.</span>
                    <span class="c1"># 小顶堆的值以当前序列的得分为准, 顺便也把候选集的id和候选集本身存储起来.</span>
                    <span class="n">add2heap</span><span class="p">(</span><span class="n">topk</span><span class="p">,</span> <span class="p">(</span><span class="n">can</span><span class="o">.</span><span class="n">seq_score</span><span class="p">(),</span> <span class="nb">id</span><span class="p">(</span><span class="n">can</span><span class="p">),</span> <span class="n">can</span><span class="p">),</span> <span class="n">k</span><span class="p">)</span>

            <span class="c1"># 当前候选集是堆元素的index=2的值can.</span>
            <span class="n">curr</span> <span class="o">=</span> <span class="p">[</span><span class="n">items</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="k">for</span> <span class="n">items</span> <span class="ow">in</span> <span class="n">topk</span><span class="p">]</span>
            <span class="c1"># 候选集数量已经达到搜索宽度的时候, 停止搜索.</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">completed</span><span class="p">)</span> <span class="o">==</span> <span class="n">beam_size</span><span class="p">:</span>
                <span class="k">break</span>

        <span class="c1"># 将最后产生的候选集追加进completed中.</span>
        <span class="n">completed</span> <span class="o">+=</span> <span class="n">curr</span>

        <span class="c1"># 按照得分进行降序排列, 取分数最高的作为当前解码结果序列.</span>
        <span class="n">result</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">completed</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">seq_score</span><span class="p">(),</span> <span class="n">reverse</span><span class="o">=</span><span class="bp">True</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">tokens</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="c1"># 上面的两个函数best_k()和beam_search()是6.2小节为了支持Beam-search解码的新函数</span>
    <span class="c1"># --------------------------------------------------------------------------------------</span>


    <span class="nd">@timer</span><span class="p">(</span><span class="n">module</span><span class="o">=</span><span class="s1">'doing prediction'</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">predict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">text</span><span class="p">,</span> <span class="n">tokenize</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">beam_search</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="c1"># 很重要的一个参数是将beam_search设置为True</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">text</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">and</span> <span class="n">tokenize</span><span class="p">:</span>
            <span class="n">text</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">jieba</span><span class="o">.</span><span class="n">cut</span><span class="p">(</span><span class="n">text</span><span class="p">))</span>
        <span class="c1"># 做模型所需的若干张量的初始化操作</span>
        <span class="n">x</span><span class="p">,</span> <span class="n">oov</span> <span class="o">=</span> <span class="n">source2ids</span><span class="p">(</span><span class="n">text</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">vocab</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">DEVICE</span><span class="p">)</span>
        <span class="n">len_oovs</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">oov</span><span class="p">)])</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">DEVICE</span><span class="p">)</span>
        <span class="n">x_padding_masks</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">ne</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">byte</span><span class="p">()</span><span class="o">.</span><span class="n">float</span><span class="p">()</span>

        <span class="c1"># ------------------------------------------------------------------------</span>
        <span class="c1"># 下面是6.2小节的新增代码部分, 采用beam search策略进行解码</span>
        <span class="k">if</span> <span class="n">beam_search</span><span class="p">:</span>
            <span class="n">summary</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">beam_search</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
                                       <span class="n">max_sum_len</span><span class="o">=</span><span class="n">config</span><span class="o">.</span><span class="n">max_dec_steps</span><span class="p">,</span>
                                       <span class="n">beam_size</span><span class="o">=</span><span class="n">config</span><span class="o">.</span><span class="n">beam_size</span><span class="p">,</span>
                                       <span class="n">len_oovs</span><span class="o">=</span><span class="n">len_oovs</span><span class="p">,</span>
                                       <span class="n">x_padding_masks</span><span class="o">=</span><span class="n">x_padding_masks</span><span class="p">)</span>
        <span class="c1"># ------------------------------------------------------------------------</span>

        <span class="c1"># 采用贪心策略进行解码</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">summary</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">greedy_search</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
                                         <span class="n">max_sum_len</span><span class="o">=</span><span class="n">config</span><span class="o">.</span><span class="n">max_dec_steps</span><span class="p">,</span>
                                         <span class="n">len_oovs</span><span class="o">=</span><span class="n">len_oovs</span><span class="p">,</span>
                                         <span class="n">x_padding_masks</span><span class="o">=</span><span class="n">x_padding_masks</span><span class="p">)</span>

        <span class="c1"># 将数字化ids张量转换为自然语言文本</span>
        <span class="n">summary</span> <span class="o">=</span> <span class="n">outputids2words</span><span class="p">(</span><span class="n">summary</span><span class="p">,</span> <span class="n">oov</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">vocab</span><span class="p">)</span>

        <span class="c1"># 在模型摘要结果中删除掉&lt;SOS&gt;, &lt;EOS&gt;字符.</span>
        <span class="k">return</span> <span class="n">summary</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">'&lt;SOS&gt;'</span><span class="p">,</span> <span class="s1">''</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">'&lt;EOS&gt;'</span><span class="p">,</span> <span class="s1">''</span><span class="p">)</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
</code></pre></div>


<hr>
<ul>
<li>调用:</li>
</ul>
<div class="codehilite" id="__code_8"><button class="md-clipboard" title="复制" data-clipboard-target="#__code_8 pre, #__code_8 code"><span class="md-clipboard__message"></span></button><pre id="__code_9"><span></span><button class="md-clipboard" title="复制" data-clipboard-target="#__code_9 pre, #__code_9 code"><span class="md-clipboard__message"></span></button><code><span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">"__main__"</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="s1">'实例化Predict对象, 构建dataset和vocab......'</span><span class="p">)</span>
    <span class="n">pred</span> <span class="o">=</span> <span class="n">Predict</span><span class="p">()</span>
    <span class="k">print</span><span class="p">(</span><span class="s1">'vocab_size: '</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">pred</span><span class="o">.</span><span class="n">vocab</span><span class="p">))</span>
    <span class="c1"># Randomly pick a sample in test set to predict.</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">config</span><span class="o">.</span><span class="n">val_data_path</span><span class="p">,</span> <span class="s1">'r'</span><span class="p">)</span> <span class="k">as</span> <span class="n">test</span><span class="p">:</span>
        <span class="n">picked</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">test</span><span class="p">))</span>
        <span class="n">source</span><span class="p">,</span> <span class="n">ref</span> <span class="o">=</span> <span class="n">picked</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">'&lt;SEP&gt;'</span><span class="p">)</span>

    <span class="k">print</span><span class="p">(</span><span class="s1">'source: '</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="s1">'</span><span class="se">\n</span><span class="s1">'</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="s1">'******************************************'</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="s1">'ref: '</span><span class="p">,</span> <span class="n">ref</span><span class="p">,</span> <span class="s1">'</span><span class="se">\n</span><span class="s1">'</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="s1">'******************************************'</span><span class="p">)</span>
    <span class="n">greedy_prediction</span> <span class="o">=</span> <span class="n">pred</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">source</span><span class="o">.</span><span class="n">split</span><span class="p">(),</span>  <span class="n">beam_search</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="s1">'greedy: '</span><span class="p">,</span> <span class="n">greedy_prediction</span><span class="p">,</span> <span class="s1">'</span><span class="se">\n</span><span class="s1">'</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="s1">'******************************************'</span><span class="p">)</span>
    <span class="n">beam_prediction</span> <span class="o">=</span> <span class="n">pred</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">source</span><span class="o">.</span><span class="n">split</span><span class="p">(),</span>  <span class="n">beam_search</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="s1">'beam: '</span><span class="p">,</span> <span class="n">beam_prediction</span><span class="p">,</span> <span class="s1">'</span><span class="se">\n</span><span class="s1">'</span><span class="p">)</span>
</code></pre></div>


<hr>
<ul>
<li>输出结果1:</li>
</ul>
<div class="codehilite" id="__code_10"><button class="md-clipboard" title="复制" data-clipboard-target="#__code_10 pre, #__code_10 code"><span class="md-clipboard__message"></span></button><pre id="__code_11"><span></span><button class="md-clipboard" title="复制" data-clipboard-target="#__code_11 pre, #__code_11 code"><span class="md-clipboard__message"></span></button><code>实例化Predict对象, 构建dataset和vocab......
Reading dataset /home/ec2-user/ec2-user/zhudejun/text_summary/text_summary/pgn/data/train.txt... 69999 pairs.
9.523097276687622 secs used for  initalize predicter
vocab_size:  20004
source:  行驶 过程 中 不 小心 启动 键 一下 ， 车子 熄火 ， 变速箱 发动机 影响 大 ， 没有 影响 ， 放心 谢谢 ？ ？ 不 客气 

******************************************
ref:  没有 影响 

******************************************
0.011927127838134766 secs used for  doing prediction
greedy:  没有 影响 

******************************************
0.34371519088745117 secs used for  doing prediction
beam:  不会 影响 ， 放心 ， 不会 影响 ， 放心 ， 不会 影响 ， 放心 行驶 
</code></pre></div>


<hr>
<ul>
<li>输出结果2:</li>
</ul>
<div class="codehilite" id="__code_12"><button class="md-clipboard" title="复制" data-clipboard-target="#__code_12 pre, #__code_12 code"><span class="md-clipboard__message"></span></button><pre id="__code_13"><span></span><button class="md-clipboard" title="复制" data-clipboard-target="#__code_13 pre, #__code_13 code"><span class="md-clipboard__message"></span></button><code>实例化Predict对象, 构建dataset和vocab......
Reading dataset /home/ec2-user/ec2-user/zhudejun/text_summary/text_summary/pgn/data/train.txt... 69999 pairs.
9.546478748321533 secs used for  initalize predicter
vocab_size:  20004
source:  2016 款 9.5 代 本田雅阁 智尊版 2.4 排量 ， 2017 年 5 月份 提 车 。 现在 5 200 公里 ， 首保加 4S店 全 合成 机油 。 马上 进行 二保 ， 听说 全 合成 机油 100 00 公里 再 更换 ， 当前 5 200 公里 ， 想 请问 大师 ， 以上 情况 ， 需要 更换 机油 机油 格 ？ ！ 全 合成 机油 主要 提炼 过程 矿物油 好 ， 不 建议 使用 1 万公里 ， 发动机 没有 太大 危害 ， 后期 运行 中 ， 积碳 油泥 始终 会 产生 。 建议 用全 合成 机油 时 ， 750 0 公里 更换 保养 一次 保养 间隔 公里 数 时间 计算 ， 现在 5 200 公里 ， 下次 保养 里程 数 750 0 ， 12700 保养 。 时间 间隔 半年 我首保 公里 读数 582 公里 ， 全 合成 机油 ， 8082 公里 再 更换 机油 机油 格 ？ ， 全 合成 机油 ， 不能 太久 ， 使用 太久 ， 全 合成 机油 性能 下降 以后 ， 油泥 积碳 产生 普通 油 5000 公里 更换 ， 产生 油泥 ， 发动机 没有 好处 好 ， 明白 。 二保 暂时 不 更换 机油 机油 格 ， 4S 可能 会 说 车主 自行 脱保 。 至少 公里 数 保养 ， 不会 ， 首保 师傅 清洗 节气门 ， 不 愿意 ， 是否 每次 保养 都 清洗 节气门 ？ 2 3 万公里 清洗 一次 4S 师傅 清洗 节气门 ， 都 不 愿意 ， 问题 ， 说 车主 驾驶 习惯 不良 造成 积碳 ， 油耗 过高 问题 清洗 节气门 收费 ， 知道 不用 每次 保养 都 清洗 好 好 谢谢 李师傅 不 客气 

******************************************
ref:  用全 合成 机油 ， 换油 周期 最多 750 0 公里 间隔 。 

******************************************
0.05549979209899902 secs used for  doing prediction
greedy:  全 合成 机油 一年 一万公里 更换 一次 ， 全 合成 机油 一年 一万公里 更换 一次 ， 全 合成 机油 

******************************************
0.24428892135620117 secs used for  doing prediction
beam:  这款 车 全 合成 机油 一年 750 0 公里 一年 保养 一次 ， 后期 维护 保养 周期 750 0 公里 
</code></pre></div>


<hr>
<blockquote>
<ul>
<li>模型预测结论: 对于很短的人工摘要, 有些时候greedy decode会得到更好的结果; 对于稍长的人工摘要, 还是beam search的摘要更合理, 语义更丰富准确, 也减少了重复性.</li>
</ul>
</blockquote>
<hr>
<hr>
<h3 id="rougebaseline-4">利用ROUGE评估baseline-4模型</h3>
<h4 id="pgnbaseline-4">对PGN的baseline-4模型进行评估</h4>
<ul>
<li>在对baseline-4模型进行评估前, 先明确两个最重要的参数设置.<ul>
<li>max_dec_steps: 最大解码长度</li>
<li>beam_size: 采用beam-search策略时的搜索宽度</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>代码文件路径: /home/ec2-user/text_summary/pgn/utils/config.py</li>
</ul>
<div class="codehilite" id="__code_14"><button class="md-clipboard" title="复制" data-clipboard-target="#__code_14 pre, #__code_14 code"><span class="md-clipboard__message"></span></button><pre id="__code_15"><span></span><button class="md-clipboard" title="复制" data-clipboard-target="#__code_15 pre, #__code_15 code"><span class="md-clipboard__message"></span></button><code><span class="c1"># 最大解码长度设置为30, 这个超参数对结果摘要也有较大影响.</span>
<span class="n">max_dec_steps</span><span class="o">=</span><span class="mi">30</span>

<span class="c1"># beam-search的搜索宽度, 对解码的效率, 效果影响很大, 建议在2, 3, 4中选择, 不要更大.</span>
<span class="n">beam_size</span><span class="o">=</span><span class="mi">3</span>
</code></pre></div>


<hr>
<ul>
<li>评估代码没有任何变化, 完全照搬baseline-3的源代码即可:<ul>
<li>代码文件路径: /home/ec2-user/text_summary/pgn/src/rouge_eval.py</li>
</ul>
</li>
</ul>
<div class="codehilite" id="__code_16"><button class="md-clipboard" title="复制" data-clipboard-target="#__code_16 pre, #__code_16 code"><span class="md-clipboard__message"></span></button><pre id="__code_17"><span></span><button class="md-clipboard" title="复制" data-clipboard-target="#__code_17 pre, #__code_17 code"><span class="md-clipboard__message"></span></button><code><span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">from</span> <span class="nn">rouge</span> <span class="kn">import</span> <span class="n">Rouge</span>
<span class="kn">import</span> <span class="nn">jieba</span>

<span class="n">root_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">abspath</span><span class="p">(</span><span class="vm">__file__</span><span class="p">)))</span>
<span class="n">sys</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">root_path</span><span class="p">)</span>

<span class="kn">from</span> <span class="nn">src.predict</span> <span class="kn">import</span> <span class="n">Predict</span>
<span class="kn">from</span> <span class="nn">utils.func_utils</span> <span class="kn">import</span> <span class="n">timer</span>
<span class="kn">from</span> <span class="nn">utils</span> <span class="kn">import</span> <span class="n">config</span>


<span class="k">class</span> <span class="nc">RougeEval</span><span class="p">():</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">path</span> <span class="o">=</span> <span class="n">path</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scores</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rouge</span> <span class="o">=</span> <span class="n">Rouge</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sources</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">hypos</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">refs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">process</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">process</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s1">'Reading from '</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">path</span><span class="p">)</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">path</span><span class="p">,</span> <span class="s1">'r'</span><span class="p">)</span> <span class="k">as</span> <span class="n">test</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">test</span><span class="p">:</span>
                <span class="n">source</span><span class="p">,</span> <span class="n">ref</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">'&lt;SEP&gt;'</span><span class="p">)</span>
                <span class="n">ref</span> <span class="o">=</span> <span class="n">ref</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">'。'</span><span class="p">,</span> <span class="s1">'.'</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">sources</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">source</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">refs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ref</span><span class="p">)</span>

        <span class="k">print</span><span class="p">(</span><span class="s1">'self.refs[]包含的样本数: '</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">refs</span><span class="p">))</span>
        <span class="k">print</span><span class="p">(</span><span class="n">f</span><span class="s1">'Test set contains {len(self.sources)} samples.'</span><span class="p">)</span>

    <span class="nd">@timer</span><span class="p">(</span><span class="s1">'building hypotheses'</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">build_hypos</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">predict</span><span class="p">):</span>
        <span class="c1"># Generate hypos for the dataset.</span>
        <span class="k">print</span><span class="p">(</span><span class="s1">'Building hypotheses.'</span><span class="p">)</span>
        <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">source</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sources</span><span class="p">:</span>
            <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">count</span> <span class="o">%</span> <span class="mi">1000</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">print</span><span class="p">(</span><span class="s1">'count='</span><span class="p">,</span> <span class="n">count</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">hypos</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">predict</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">source</span><span class="o">.</span><span class="n">split</span><span class="p">()))</span>

    <span class="k">def</span> <span class="nf">get_average</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">hypos</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">'Build hypotheses first!'</span>
        <span class="k">print</span><span class="p">(</span><span class="s1">'Calculating average rouge scores.'</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">rouge</span><span class="o">.</span><span class="n">get_scores</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">hypos</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">refs</span><span class="p">,</span> <span class="n">avg</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">one_sample</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">hypo</span><span class="p">,</span> <span class="n">ref</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">rouge</span><span class="o">.</span><span class="n">get_scores</span><span class="p">(</span><span class="n">hypo</span><span class="p">,</span> <span class="n">ref</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
</code></pre></div>


<hr>
<ul>
<li>调用:</li>
</ul>
<div class="codehilite" id="__code_18"><button class="md-clipboard" title="复制" data-clipboard-target="#__code_18 pre, #__code_18 code"><span class="md-clipboard__message"></span></button><pre id="__code_19"><span></span><button class="md-clipboard" title="复制" data-clipboard-target="#__code_19 pre, #__code_19 code"><span class="md-clipboard__message"></span></button><code><span class="c1"># 真实的测试机是val_data_path: dev.txt</span>
<span class="k">print</span><span class="p">(</span><span class="s1">'实例化Rouge对象......'</span><span class="p">)</span>
<span class="n">rouge_eval</span> <span class="o">=</span> <span class="n">RougeEval</span><span class="p">(</span><span class="n">config</span><span class="o">.</span><span class="n">val_data_path</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="s1">'实例化Predict对象......'</span><span class="p">)</span>
<span class="n">predict</span> <span class="o">=</span> <span class="n">Predict</span><span class="p">()</span>

<span class="c1"># 利用模型对article进行预测</span>
<span class="k">print</span><span class="p">(</span><span class="s1">'利用模型对article进行预测, 并通过Rouge对象进行评估......'</span><span class="p">)</span>
<span class="n">rouge_eval</span><span class="o">.</span><span class="n">build_hypos</span><span class="p">(</span><span class="n">predict</span><span class="p">)</span>
<span class="c1"># 将预测结果和标签abstract进行ROUGE规则计算</span>
<span class="k">print</span><span class="p">(</span><span class="s1">'开始用Rouge规则进行评估......'</span><span class="p">)</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">rouge_eval</span><span class="o">.</span><span class="n">get_average</span><span class="p">()</span>
<span class="k">print</span><span class="p">(</span><span class="s1">'rouge1: '</span><span class="p">,</span> <span class="n">result</span><span class="p">[</span><span class="s1">'rouge-1'</span><span class="p">])</span>
<span class="k">print</span><span class="p">(</span><span class="s1">'rouge2: '</span><span class="p">,</span> <span class="n">result</span><span class="p">[</span><span class="s1">'rouge-2'</span><span class="p">])</span>
<span class="k">print</span><span class="p">(</span><span class="s1">'rougeL: '</span><span class="p">,</span> <span class="n">result</span><span class="p">[</span><span class="s1">'rouge-l'</span><span class="p">])</span>

<span class="c1"># 最后将计算评估结果写入文件中</span>
<span class="k">print</span><span class="p">(</span><span class="s1">'将评估结果写入结果文件中......'</span><span class="p">)</span>
<span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s1">'../eval_result/rouge_result.txt'</span><span class="p">,</span> <span class="s1">'a'</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
    <span class="k">for</span> <span class="n">r</span><span class="p">,</span> <span class="n">metrics</span> <span class="ow">in</span> <span class="n">result</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">r</span> <span class="o">+</span> <span class="s1">'</span><span class="se">\n</span><span class="s1">'</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">metric</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">metrics</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">metric</span> <span class="o">+</span> <span class="s1">': '</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">value</span> <span class="o">*</span> <span class="mi">100</span><span class="p">)</span> <span class="o">+</span> <span class="s1">'</span><span class="se">\n</span><span class="s1">'</span><span class="p">)</span>
</code></pre></div>


<hr>
<ul>
<li>执行:</li>
</ul>
<div class="codehilite" id="__code_20"><button class="md-clipboard" title="复制" data-clipboard-target="#__code_20 pre, #__code_20 code"><span class="md-clipboard__message"></span></button><pre id="__code_21"><span></span><button class="md-clipboard" title="复制" data-clipboard-target="#__code_21 pre, #__code_21 code"><span class="md-clipboard__message"></span></button><code><span class="nb">cd</span> /home/ec2-user/text_summary/pgn/src/

python rouge_eval.py
</code></pre></div>


<hr>
<ul>
<li>输出结果:</li>
</ul>
<div class="codehilite" id="__code_22"><button class="md-clipboard" title="复制" data-clipboard-target="#__code_22 pre, #__code_22 code"><span class="md-clipboard__message"></span></button><pre id="__code_23"><span></span><button class="md-clipboard" title="复制" data-clipboard-target="#__code_23 pre, #__code_23 code"><span class="md-clipboard__message"></span></button><code>实例化Rouge对象......
Reading from  /home/ec2-user/ec2-user/zhudejun/text_summary/text_summary/pgn/data/dev.txt
self.refs[]包含的样本数:  3000
Test set contains 3000 samples.
实例化Predict对象......
Reading dataset /home/ec2-user/ec2-user/zhudejun/text_summary/text_summary/pgn/data/train.txt... 69999 pairs.
9.540595769882202 secs used for  initalize predicter
利用模型对article进行预测, 并通过Rouge对象进行评估......
Building hypotheses.
0.3612496852874756 secs used for  doing prediction
0.3378407955169678 secs used for  doing prediction
0.33907222747802734 secs used for  doing prediction
0.33692336082458496 secs used for  doing prediction
0.34388184547424316 secs used for  doing prediction
0.3351857662200928 secs used for  doing prediction
0.3377809524536133 secs used for  doing prediction
0.35638427734375 secs used for  doing prediction
0.35387086868286133 secs used for  doing prediction
0.3497180938720703 secs used for  doing prediction
0.33884239196777344 secs used for  doing prediction
0.33420300483703613 secs used for  doing prediction
0.34486865997314453 secs used for  doing prediction
0.33138418197631836 secs used for  doing prediction
0.3341488838195801 secs used for  doing prediction
0.3463015556335449 secs used for  doing prediction
0.3333241939544678 secs used for  doing prediction
0.338392972946167 secs used for  doing prediction
0.35277867317199707 secs used for  doing prediction
0.35438013076782227 secs used for  doing prediction


......
......
......


0.3353769779205322 secs used for  doing prediction
0.34035539627075195 secs used for  doing prediction
0.38248276710510254 secs used for  doing prediction
0.33664369583129883 secs used for  doing prediction
0.3500978946685791 secs used for  doing prediction
0.3417830467224121 secs used for  doing prediction
0.3423631191253662 secs used for  doing prediction
0.350400447845459 secs used for  doing prediction
0.3503289222717285 secs used for  doing prediction
0.3484373092651367 secs used for  doing prediction
0.33926868438720703 secs used for  doing prediction
0.33957529067993164 secs used for  doing prediction
0.3400390148162842 secs used for  doing prediction
1017.7808394432068 secs used for  building hypotheses
开始用Rouge规则进行评估......
Calculating average rouge scores.
rouge1:  {'f': 0.2237876211830499, 'p': 0.18118834397125683, 'r': 0.3841843120305152}
rouge2:  {'f': 0.07272050441375325, 'p': 0.05774983504844641, 'r': 0.1346595763700352}
rougeL:  {'f': 0.27544194926579235, 'p': 0.2864224165624092, 'r': 0.3228687273073168}
将评估结果写入结果文件中......
</code></pre></div>


<hr>
<ul>
<li>查看结果文件:</li>
</ul>
<div class="codehilite" id="__code_24"><button class="md-clipboard" title="复制" data-clipboard-target="#__code_24 pre, #__code_24 code"><span class="md-clipboard__message"></span></button><pre id="__code_25"><span></span><button class="md-clipboard" title="复制" data-clipboard-target="#__code_25 pre, #__code_25 code"><span class="md-clipboard__message"></span></button><code><span class="nb">cd</span> /home/ec2-user/text_summary/pgn/eval_result/

cat rouge_result.txt
</code></pre></div>


<hr>
<ul>
<li>输出结果:</li>
</ul>
<div class="codehilite" id="__code_26"><button class="md-clipboard" title="复制" data-clipboard-target="#__code_26 pre, #__code_26 code"><span class="md-clipboard__message"></span></button><pre id="__code_27"><span></span><button class="md-clipboard" title="复制" data-clipboard-target="#__code_27 pre, #__code_27 code"><span class="md-clipboard__message"></span></button><code>rouge-1
f: 22.37876211830499
p: 18.11883439712568
r: 38.41843120305152
rouge-2
f: 7.272050441375325
p: 5.774983504844641
r: 13.46595763700352
rouge-l
f: 27.544194926579234
p: 28.64224165624092
r: 32.28687273073168
</code></pre></div>


<hr>
<hr>
<h4 id="rouge">ROUGE评估结果对比</h4>
<ul>
<li>将baseline-2, baseline-3, baseline-4模型在同样的测试集上的表现展示在一起:</li>
</ul>
<div class="codehilite" id="__code_28"><button class="md-clipboard" title="复制" data-clipboard-target="#__code_28 pre, #__code_28 code"><span class="md-clipboard__message"></span></button><pre id="__code_29"><span></span><button class="md-clipboard" title="复制" data-clipboard-target="#__code_29 pre, #__code_29 code"><span class="md-clipboard__message"></span></button><code># 左侧是baseline-2模型的表现, 中间是baseline-3模型的表现, 右侧是baseline-4模型的表现

# ----------------------------------------------------------------------------------
# baseline-2                baseline-3                  baseline-4
# PGN                       PGN + coverage              PGN + coverage + beam-search
# ----------------------------------------------------------------------------------

rouge-1                     rouge-1                     rouge-1
f: 22.4840567492723         f: 23.891369972642877       f: 22.37876211830499
p: 22.48892685096682        p: 27.884799447410742       p: 18.11883439712568
r: 36.152107385286506       r: 32.746511025920974       r: 38.41843120305152

# ----------------------------------------------------------------------------------

rouge-2                     rouge-2                     rouge-2
f: 7.6855293213852995       f: 8.145260844937683        f: 7.272050441375325
p: 7.633592816230374        p: 9.507772545428752        p: 5.774983504844641
r: 12.992180038436171       r: 11.403972188579534       r: 13.46595763700352

# ----------------------------------------------------------------------------------

rouge-l                     rouge-l                     rouge-l
f: 29.79190839597577        f: 28.112397619052885       f: 27.544194926579234
p: 35.022548049923934       p: 35.51625333014313        p: 28.64224165624092
r: 31.245311823639828       r: 28.567520633785175       r: 32.28687273073168
</code></pre></div>


<hr>
<blockquote>
<ul>
<li>测试结果对比分析: 对比这3个模型的评估结果, 可以看出来采用beam-search解码的三个指标, 精确率p都有较大的下滑, 同时召回率r都有较大的提升. 同学们可以仔细思考一下这里面的原因是什么? 然后以此为出发点, 再次踏上模型优化的征途~~~ </li>
</ul>
</blockquote>
<hr>
<hr>
<h3 id="_3">小节总结</h3>
<ul>
<li>
<p>Beam-search算法:</p>
<ul>
<li>Beam-search的概念: 既不采用最大值贪心策略, 也不采用全局搜索策略, 而是折中一个k值, 将时间复杂度降低至O(T * K * N).</li>
<li>区别于Viterbi算法的动态规划全局搜索, Beam-search在时间效率上还是更高的. 但同时Beam-search无法保证得到全局最优解, 只是在较高的算法效率下得到一个较优解, 更适应工程上的需求.</li>
</ul>
</li>
<li>
<p>Beam-search策略的代码实现:</p>
<ul>
<li>配置文件的添加: 在config.py中添加关于beam-search的部分, 最重要是beam_size.</li>
<li>预测类Predict的修改: 增加类内函数用以支持beam-search的解码.</li>
<li>Beam类的构建: 在工具类函数func_utils.py中添加Beam类的代码.</li>
</ul>
</li>
<li>
<p>ROUGE评估baseline-4模型:</p>
<ul>
<li>在精确率p指标上有较大的下滑.</li>
<li>在召回率r指标上有较大的提升.</li>
</ul>
</li>
</ul>
<hr>
<blockquote>
<ul>
<li>分析: 精确率p下滑恰恰说明了采用beam-search策略生成的摘要更丰富, 不拘泥于原文表意; 同时召回率r提升恰恰说明了采用beam-search策略生成的摘要包含了更多关键的语义信息, 不遗漏重点内容, 搜索范围更广.</li>
</ul>
</blockquote>
<hr>
<hr>
<hr>
<hr>
                
                  
                
              
              
                


              
            </article>
          </div>
        </div>
      </main>
      
        
<footer class="md-footer">
  
    <div class="md-footer-nav">
      <nav class="md-footer-nav__inner md-grid">
        
          <a href="./6_1.html" title="6.1 PGN + coverage的优化模型" class="md-flex md-footer-nav__link md-footer-nav__link--prev" rel="prev">
            <div class="md-flex__cell md-flex__cell--shrink">
              <i class="md-icon md-icon--arrow-back md-footer-nav__button"></i>
            </div>
            <div class="md-flex__cell md-flex__cell--stretch md-footer-nav__title">
              <span class="md-flex__ellipsis">
                <span class="md-footer-nav__direction">
                  上一页
                </span>
                6.1 PGN + coverage的优化模型
              </span>
            </div>
          </a>
        
        
          <a href="./6_3.html" title="6.3 数据增强的优化" class="md-flex md-footer-nav__link md-footer-nav__link--next" rel="next">
            <div class="md-flex__cell md-flex__cell--stretch md-footer-nav__title">
              <span class="md-flex__ellipsis">
                <span class="md-footer-nav__direction">
                  下一页
                </span>
                6.3 数据增强的优化
              </span>
            </div>
            <div class="md-flex__cell md-flex__cell--shrink">
              <i class="md-icon md-icon--arrow-forward md-footer-nav__button"></i>
            </div>
          </a>
        
      </nav>
    </div>
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-footer-copyright">
        
          <div class="md-footer-copyright__highlight">
            ©Copyright 2020, AITutorials.CN This website has been reviewed by the review agency. 京ICP备19006137号
          </div>
        
        powered by
        <a href="https://www.mkdocs.org/">MkDocs</a>
        and
        <a href="https://squidfunk.github.io/mkdocs-material/">
          Material for MkDocs</a>
      </div>
      
  <div class="md-footer-social">
    <link rel="stylesheet" href="./index_files/font-awesome.css">
    
      <a href="https://www.linkedin.com/in/%E7%A7%91%E6%8A%80%E6%9C%89%E9%99%90%E5%85%AC%E5%8F%B8-%E5%8C%97%E4%BA%AC%E6%A9%98%E6%98%9F-6bb7081a1/" class="md-footer-social__link fa fa-linkedin"></a>
    
      <a href="https://weibo.com/u/3469990762?is_all=1" class="md-footer-social__link fa fa-weibo"></a>
    
      <a href="http://bitbucket.org/AITutorials" class="md-footer-social__link fa fa-bitbucket"></a>
    
      <a href="https://github.com/AITutorials/datasets/issues" class="md-footer-social__link fa fa-gitlab"></a>
    
  </div>

    </div>
  </div>
</footer>
      
    </div>
    
      <script src="./index_files/application.245445c6.js"></script>
      
        
        
          
          <script src="./index_files/lunr.stemmer.support.js"></script>
          
            
              
                <script src="./index_files/tinyseg.js"></script>
              
              
                <script src="./index_files/lunr.ja.js"></script>
              
            
          
          
        
      
      <script>app.initialize({version:"1.1.2",url:{base:".."}})</script>
      
    
  
</body></html>