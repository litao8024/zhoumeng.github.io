
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      
      <link rel="icon" href="../../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.1.2, mkdocs-material-7.1.5">
    
    
      
        <title>Faster-RCNN原理与实现 - 深度学习与CV</title>
      
    
    
      <link rel="stylesheet" href="../../assets/stylesheets/main.bde7dde4.min.css">
      
        
        <link rel="stylesheet" href="../../assets/stylesheets/palette.ef6f36e2.min.css">
        
      
    
    
    
      
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,400,400i,700%7CRoboto+Mono&display=fallback">
        <style>:root{--md-text-font-family:"Roboto";--md-code-font-family:"Roboto Mono"}</style>
      
    
    
    
    
      
    
    
  </head>
  
  
    
    
    
    
    
    <body dir="ltr" data-md-color-scheme="" data-md-color-primary="none" data-md-color-accent="none">
  
    
    <script>function __prefix(e){return new URL("../..",location).pathname+"."+e}function __get(e,t=localStorage){return JSON.parse(t.getItem(__prefix(e)))}</script>
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#43-faster-rcnn" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
      <header class="md-header" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href="../.." title="深度学习与CV" class="md-header__button md-logo" aria-label="深度学习与CV" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54z"/></svg>

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            深度学习与CV
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              Faster-RCNN原理与实现
            
          </span>
        </div>
      </div>
    </div>
    
    
    
      <label class="md-header__button md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5z"/></svg>
      </label>
      
<div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" data-md-state="active" required>
      <label class="md-search__icon md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5z"/></svg>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12z"/></svg>
      </label>
      <button type="reset" class="md-search__icon md-icon" aria-label="Clear" tabindex="-1">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41z"/></svg>
      </button>
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
  </nav>
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    


<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../.." title="深度学习与CV" class="md-nav__button md-logo" aria-label="深度学习与CV" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54z"/></svg>

    </a>
    深度学习与CV
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
      

  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_1" type="checkbox" id="__nav_1" >
      
      <label class="md-nav__link" for="__nav_1">
        课程介绍
        <span class="md-nav__icon md-icon"></span>
      </label>
      <nav class="md-nav" aria-label="课程介绍" data-md-level="1">
        <label class="md-nav__title" for="__nav_1">
          <span class="md-nav__icon md-icon"></span>
          课程介绍
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../introduction/section1/index.html" class="md-nav__link">
        深度学习
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../introduction/section2/index.html" class="md-nav__link">
        计算机视觉（CV）
      </a>
    </li>
  

          
        </ul>
      </nav>
    </li>
  

    
      
      
      

  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_2" type="checkbox" id="__nav_2" >
      
      <label class="md-nav__link" for="__nav_2">
        tensorflow入门
        <span class="md-nav__icon md-icon"></span>
      </label>
      <nav class="md-nav" aria-label="tensorflow入门" data-md-level="1">
        <label class="md-nav__title" for="__nav_2">
          <span class="md-nav__icon md-icon"></span>
          tensorflow入门
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../tensorFlow/section1/index.html" class="md-nav__link">
        tensorflow和keras简介
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../tensorFlow/section2/index.html" class="md-nav__link">
        快速入门模型
      </a>
    </li>
  

          
        </ul>
      </nav>
    </li>
  

    
      
      
      

  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_3" type="checkbox" id="__nav_3" >
      
      <label class="md-nav__link" for="__nav_3">
        深度神经网络
        <span class="md-nav__icon md-icon"></span>
      </label>
      <nav class="md-nav" aria-label="深度神经网络" data-md-level="1">
        <label class="md-nav__title" for="__nav_3">
          <span class="md-nav__icon md-icon"></span>
          深度神经网络
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../deeplearning/section1/index.html" class="md-nav__link">
        神经网络简介
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../deeplearning/section2/index.html" class="md-nav__link">
        常见的损失函数
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../deeplearning/section3/index.html" class="md-nav__link">
        深度学习的优化方法
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../deeplearning/section4/index.html" class="md-nav__link">
        深度学习的正则化
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../deeplearning/section5/index.html" class="md-nav__link">
        神经网络案例
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../deeplearning/section6/index.html" class="md-nav__link">
        卷积神经网络CNN
      </a>
    </li>
  

          
        </ul>
      </nav>
    </li>
  

    
      
      
      

  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_4" type="checkbox" id="__nav_4" >
      
      <label class="md-nav__link" for="__nav_4">
        图像分类
        <span class="md-nav__icon md-icon"></span>
      </label>
      <nav class="md-nav" aria-label="图像分类" data-md-level="1">
        <label class="md-nav__title" for="__nav_4">
          <span class="md-nav__icon md-icon"></span>
          图像分类
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../imageClassification/section1/index.html" class="md-nav__link">
        图像分类简介
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../imageClassification/section2/index.html" class="md-nav__link">
        AlexNet
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../imageClassification/section3/index.html" class="md-nav__link">
        VGG
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../imageClassification/section4/index.html" class="md-nav__link">
        GoogLeNet
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../imageClassification/section5/index.html" class="md-nav__link">
        ResNet
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../imageClassification/section6/index.html" class="md-nav__link">
        图像增强方法
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../imageClassification/section7/index.html" class="md-nav__link">
        模型微调
      </a>
    </li>
  

          
        </ul>
      </nav>
    </li>
  

    
      
      
      

  
  
    
  
  
    
    <li class="md-nav__item md-nav__item--active md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_5" type="checkbox" id="__nav_5" checked>
      
      <label class="md-nav__link" for="__nav_5">
        目标检测
        <span class="md-nav__icon md-icon"></span>
      </label>
      <nav class="md-nav" aria-label="目标检测" data-md-level="1">
        <label class="md-nav__title" for="__nav_5">
          <span class="md-nav__icon md-icon"></span>
          目标检测
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
  
  
  
    <li class="md-nav__item">
      <a href="../01.overview/index.html" class="md-nav__link">
        目标检测概述
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../02.RCNN/index.html" class="md-nav__link">
        RCNN网络基础
      </a>
    </li>
  

          
            
  
  
    
  
  
    <li class="md-nav__item md-nav__item--active">
      
      <input class="md-nav__toggle md-toggle" data-md-toggle="toc" type="checkbox" id="__toc">
      
      
        
      
      
        <label class="md-nav__link md-nav__link--active" for="__toc">
          Faster-RCNN原理与实现
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <a href="#" class="md-nav__link md-nav__link--active">
        Faster-RCNN原理与实现
      </a>
      
        
<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#1" class="md-nav__link">
    1. 网络工作流程
  </a>
  
    <nav class="md-nav" aria-label="1. 网络工作流程">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#11" class="md-nav__link">
    1.1 数据加载
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#12" class="md-nav__link">
    1.2 模型加载
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#13" class="md-nav__link">
    1.3 模型预测过程
  </a>
  
    <nav class="md-nav" aria-label="1.3 模型预测过程">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#131-rpn" class="md-nav__link">
    1.3.1 RPN获取候选区域
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#132-fastrcnn" class="md-nav__link">
    1.3.2 FastRCNN进行目标检测
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#2" class="md-nav__link">
    2.模型结构详解
  </a>
  
    <nav class="md-nav" aria-label="2.模型结构详解">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#21backbone" class="md-nav__link">
    2.1backbone
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#22-rpn" class="md-nav__link">
    2.2 RPN网络
  </a>
  
    <nav class="md-nav" aria-label="2.2 RPN网络">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#221-anchors" class="md-nav__link">
    2.2.1 anchors
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#222-rpn" class="md-nav__link">
    2.2.2 RPN分类
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#223-rpn" class="md-nav__link">
    2.2.3 RPN回归
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#424-proposal" class="md-nav__link">
    4.2.4 Proposal层
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#23-roipooling" class="md-nav__link">
    2.3 ROIPooling
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#24" class="md-nav__link">
    2.4 目标分类与回归
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#3-fasterrcnn" class="md-nav__link">
    3 FasterRCNN的训练
  </a>
  
    <nav class="md-nav" aria-label="3 FasterRCNN的训练">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#31-rpn" class="md-nav__link">
    3.1 RPN网络的训练
  </a>
  
    <nav class="md-nav" aria-label="3.1 RPN网络的训练">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#311" class="md-nav__link">
    3.1.1正负样本标记
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#312-rpn" class="md-nav__link">
    3.1.2 RPN网络的损失函数
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#313" class="md-nav__link">
    3.1.3 训练过程
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#314" class="md-nav__link">
    3.1.4 实现
  </a>
  
    <nav class="md-nav" aria-label="3.1.4 实现">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#1_1" class="md-nav__link">
    1、正负样本设置
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2_1" class="md-nav__link">
    2、损失函数
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#32-fastrcnn" class="md-nav__link">
    3.2 FastRCNN网络的训练
  </a>
  
    <nav class="md-nav" aria-label="3.2 FastRCNN网络的训练">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#321" class="md-nav__link">
    3.2.1 正负样本标记
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#312-fastrcnn" class="md-nav__link">
    3.1.2  FastRCNN的损失函数
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#323" class="md-nav__link">
    3.2.3.训练过程
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#324" class="md-nav__link">
    3.2.4 实现
  </a>
  
    <nav class="md-nav" aria-label="3.2.4 实现">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#1_2" class="md-nav__link">
    1、正负样本设置
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2_2" class="md-nav__link">
    2、损失函数
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#33" class="md-nav__link">
    3.3 共享卷积训练
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#4" class="md-nav__link">
    4 端到端训练
  </a>
  
    <nav class="md-nav" aria-label="4 端到端训练">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#41" class="md-nav__link">
    4.1 数据加载
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#42" class="md-nav__link">
    4.2. 模型实例化
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#43" class="md-nav__link">
    4.3 模型训练
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
    </ul>
  
</nav>
      
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../04.yolo/index.html" class="md-nav__link">
        YOLO系列算法
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../05.yoloV3-demo/index.html" class="md-nav__link">
        YOLOV3案例
      </a>
    </li>
  

          
        </ul>
      </nav>
    </li>
  

    
      
      
      

  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_6" type="checkbox" id="__nav_6" >
      
      <label class="md-nav__link" for="__nav_6">
        目标分割
        <span class="md-nav__icon md-icon"></span>
      </label>
      <nav class="md-nav" aria-label="目标分割" data-md-level="1">
        <label class="md-nav__title" for="__nav_6">
          <span class="md-nav__icon md-icon"></span>
          目标分割
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../imageSegmentation/section1/index.html" class="md-nav__link">
        目标分割介绍
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../imageSegmentation/section2/index.html" class="md-nav__link">
        语义分割：FCN和UNet
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../imageSegmentation/section3/index.html" class="md-nav__link">
        UNet案例
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../imageSegmentation/section4/index.html" class="md-nav__link">
        实例分割：Mask RCNN
      </a>
    </li>
  

          
        </ul>
      </nav>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    
<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#1" class="md-nav__link">
    1. 网络工作流程
  </a>
  
    <nav class="md-nav" aria-label="1. 网络工作流程">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#11" class="md-nav__link">
    1.1 数据加载
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#12" class="md-nav__link">
    1.2 模型加载
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#13" class="md-nav__link">
    1.3 模型预测过程
  </a>
  
    <nav class="md-nav" aria-label="1.3 模型预测过程">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#131-rpn" class="md-nav__link">
    1.3.1 RPN获取候选区域
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#132-fastrcnn" class="md-nav__link">
    1.3.2 FastRCNN进行目标检测
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#2" class="md-nav__link">
    2.模型结构详解
  </a>
  
    <nav class="md-nav" aria-label="2.模型结构详解">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#21backbone" class="md-nav__link">
    2.1backbone
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#22-rpn" class="md-nav__link">
    2.2 RPN网络
  </a>
  
    <nav class="md-nav" aria-label="2.2 RPN网络">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#221-anchors" class="md-nav__link">
    2.2.1 anchors
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#222-rpn" class="md-nav__link">
    2.2.2 RPN分类
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#223-rpn" class="md-nav__link">
    2.2.3 RPN回归
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#424-proposal" class="md-nav__link">
    4.2.4 Proposal层
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#23-roipooling" class="md-nav__link">
    2.3 ROIPooling
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#24" class="md-nav__link">
    2.4 目标分类与回归
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#3-fasterrcnn" class="md-nav__link">
    3 FasterRCNN的训练
  </a>
  
    <nav class="md-nav" aria-label="3 FasterRCNN的训练">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#31-rpn" class="md-nav__link">
    3.1 RPN网络的训练
  </a>
  
    <nav class="md-nav" aria-label="3.1 RPN网络的训练">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#311" class="md-nav__link">
    3.1.1正负样本标记
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#312-rpn" class="md-nav__link">
    3.1.2 RPN网络的损失函数
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#313" class="md-nav__link">
    3.1.3 训练过程
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#314" class="md-nav__link">
    3.1.4 实现
  </a>
  
    <nav class="md-nav" aria-label="3.1.4 实现">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#1_1" class="md-nav__link">
    1、正负样本设置
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2_1" class="md-nav__link">
    2、损失函数
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#32-fastrcnn" class="md-nav__link">
    3.2 FastRCNN网络的训练
  </a>
  
    <nav class="md-nav" aria-label="3.2 FastRCNN网络的训练">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#321" class="md-nav__link">
    3.2.1 正负样本标记
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#312-fastrcnn" class="md-nav__link">
    3.1.2  FastRCNN的损失函数
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#323" class="md-nav__link">
    3.2.3.训练过程
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#324" class="md-nav__link">
    3.2.4 实现
  </a>
  
    <nav class="md-nav" aria-label="3.2.4 实现">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#1_2" class="md-nav__link">
    1、正负样本设置
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2_2" class="md-nav__link">
    2、损失函数
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#33" class="md-nav__link">
    3.3 共享卷积训练
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#4" class="md-nav__link">
    4 端到端训练
  </a>
  
    <nav class="md-nav" aria-label="4 端到端训练">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#41" class="md-nav__link">
    4.1 数据加载
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#42" class="md-nav__link">
    4.2. 模型实例化
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#43" class="md-nav__link">
    4.3 模型训练
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          <div class="md-content" data-md-component="content">
            <article class="md-content__inner md-typeset">
              
                
                
                <h1 id="43-faster-rcnn">4.3 Faster-RCNN网络<a class="headerlink" href="#43-faster-rcnn" title="Permanent link">&para;</a></h1>
<p><strong>学习目标</strong></p>
<ul>
<li>熟悉FasterRCNN目标检测的思想</li>
<li>知道anchor（锚框）的思想</li>
<li>掌握RPN网络是如何进行候选区域的生成的</li>
<li>掌握ROIPooling的使用方法</li>
<li>知道fasterRCNN的训练方法</li>
</ul>
<hr />
<p><img alt="image-20200914143645050" src="../assets/image-20200914143645050.png" /></p>
<p>在R-CNN和Fast RCNN的基础上，在2016年提出了Faster RCNN网络模型，在结构上，Faster RCNN已经将候选区域的生成，特征提取，目标分类及目标框的回归都整合在了一个网络中，综合性能有较大提高，在检测速度方面尤为明显。接下来我们给大家详细介绍fasterRCNN网络模型。网络基本结构如下图所示：</p>
<p><img alt="image-20200914161108604" src="../assets/image-20200914161108604.png" /></p>
<p>Faster RCNN可以看成是区域生成网络(RPN)与Fast RCNN的组合，其中区域生成网络(RPN)替代选择性搜索来生成候选区域，Fast RCNN用来进行目标检测。</p>
<h2 id="1">1. 网络工作流程<a class="headerlink" href="#1" title="Permanent link">&para;</a></h2>
<p>FasterRCNN的工作流程是：</p>
<p><img alt="image-20201230100055563" src="../assets/image-20201230100055563.png" /></p>
<p>1、<strong>特征提取</strong>：将整个图像缩放至固定的大小输入到CNN网络中进行特征提取，得到特征图。</p>
<p>2、<strong>候选区域提取</strong>：输入特征图，使用区域生成网络RPN，产生一些列的候选区域</p>
<p>3、<strong>ROIPooling</strong>: 与Fast RCNN网络中一样，使用最大池化固定候选区域的尺寸，送入后续网络中进行处理</p>
<p>4、<strong>目标分类和回归</strong>：与Fast RCNN网络中一样，使用两个同级层:K+1个类别的SoftMax分类层和边框的回归层，来完成目标的分类和回归。</p>
<p>Faster R-CNN的流程与Fast R-CNN的区别不是很大，重要的改进是使用RPN网络来替代选择性搜索获取候选区域，所以我们可以将Faster R-CNN网络看做RPN和Fast R-CNN网络的结合。</p>
<p>接下来我们来看下该网络预训练模型的使用过程，模型源码位置：fasterRCNN中，如下图所示：</p>
<p><img alt="image-20201230104009045" src="../assets/image-20201230104009045.png" /></p>
<p>detection文件夹中是模型，数据的实现，weights中包含网络的预训练模型。接下来我们按照以下步骤进行目标检测：</p>
<p>1、获取数据和加载预训练网络</p>
<p>2、获取RPN网络生成的候选区域</p>
<p>3、获取网络的目标检测结果</p>
<p>首先导入相应的工具包：</p>
<div class="highlight"><pre><span></span><code><span class="c1"># 获取VOC数据使用</span>
<span class="kn">from</span> <span class="nn">detection.datasets</span> <span class="kn">import</span> <span class="n">pascal_voc</span>
<span class="c1"># 绘图</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="c1"># 模型构建</span>
<span class="kn">from</span> <span class="nn">detection.models.detectors</span> <span class="kn">import</span> <span class="n">faster_rcnn</span>
<span class="kn">import</span> <span class="nn">tensorflow</span> <span class="k">as</span> <span class="nn">tf</span>
<span class="c1"># 图像展示</span>
<span class="kn">import</span> <span class="nn">visualize</span>
</code></pre></div>
<h3 id="11">1.1 数据加载<a class="headerlink" href="#11" title="Permanent link">&para;</a></h3>
<p>加载voc数据集中的一张图片进行网络预测：</p>
<div class="highlight"><pre><span></span><code><span class="c1"># 实例化voc数据集的类，获取送入网络中的一张图片</span>
<span class="n">pascal</span> <span class="o">=</span> <span class="n">pascal_voc</span><span class="o">.</span><span class="n">pascal_voc</span><span class="p">(</span><span class="s2">&quot;train&quot;</span><span class="p">)</span>
<span class="c1"># image：送入网络中的数据，imagemeta:图像的yuan&#39;x</span>
<span class="n">image</span><span class="p">,</span><span class="n">imagemeta</span><span class="p">,</span><span class="n">bbox</span><span class="p">,</span><span class="n">label</span> <span class="o">=</span> <span class="n">pascal</span><span class="p">[</span><span class="mi">218</span><span class="p">]</span>
</code></pre></div>
<p>在将图像送入网络之前，我们对其进行了尺度的调整，标准化等处理，获取可展示的图像：</p>
<div class="highlight"><pre><span></span><code><span class="c1"># 图像的均值和标准差</span>
<span class="n">img_mean</span> <span class="o">=</span> <span class="p">(</span><span class="mf">122.7717</span><span class="p">,</span> <span class="mf">115.9465</span><span class="p">,</span> <span class="mf">102.9801</span><span class="p">)</span>
<span class="n">img_std</span> <span class="o">=</span> <span class="p">(</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">)</span>
<span class="c1"># RGB图像</span>
<span class="n">rgd_image</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">image</span><span class="o">+</span><span class="n">img_mean</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
</code></pre></div>
<p>获取原始图像，进行比较：</p>
<div class="highlight"><pre><span></span><code><span class="c1"># 获取原始图像</span>
<span class="kn">from</span> <span class="nn">detection.datasets.utils</span> <span class="kn">import</span> <span class="n">get_original_image</span>
<span class="n">ori_img</span> <span class="o">=</span> <span class="n">get_original_image</span><span class="p">(</span><span class="n">image</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">imagemeta</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">img_mean</span><span class="p">)</span>
</code></pre></div>
<p>将图像进行对比显示：</p>
<div class="highlight"><pre><span></span><code><span class="c1"># 展示原图像和送入网络中图像</span>
<span class="n">rgd_image</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">image</span><span class="o">+</span><span class="n">img_mean</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
<span class="n">fig</span><span class="p">,</span><span class="n">axes</span><span class="o">=</span><span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="n">nrows</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">ncols</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">8</span><span class="p">),</span><span class="n">dpi</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>
<span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">ori_img</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;uint8&#39;</span><span class="p">))</span>
<span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s2">&quot;原图像&quot;</span><span class="p">)</span>
<span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">rgd_image</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s2">&quot;送入网络中的图像&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</code></pre></div>
<p><img alt="image-20201230112653308" src="../assets/image-20201230112653308.png" /></p>
<p>将原图像的长边缩放为1216，短边按相应比例进行调整后，并按照均值进行填充</p>
<div class="highlight"><pre><span></span><code><span class="c1"># 原图像的大小</span>
<span class="n">ori_img</span><span class="o">.</span><span class="n">shape</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code>(375, 500, 3)
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="c1"># 送入网络中图像的大小</span>
<span class="n">image</span><span class="o">.</span><span class="n">shape</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code>(1, 1216, 1216, 3)
</code></pre></div>
<p>imagemeta中的信息是：原图像大小，图像缩放后的大小，送入网络中图像的大小，图像缩放比例，图像是否翻转（未使用）。</p>
<div class="highlight"><pre><span></span><code><span class="c1"># 原始图像和送入网络中图像的信息</span>
<span class="n">imagemeta</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">array</span><span class="p">([[</span> <span class="mf">375.</span>   <span class="p">,</span>  <span class="mf">500.</span>   <span class="p">,</span>    <span class="mf">3.</span>   <span class="p">,</span>  <span class="mf">912.</span>   <span class="p">,</span> <span class="mf">1216.</span>   <span class="p">,</span>    <span class="mf">3.</span>   <span class="p">,</span>
        <span class="mf">1216.</span>   <span class="p">,</span> <span class="mf">1216.</span>   <span class="p">,</span>    <span class="mf">3.</span>   <span class="p">,</span>    <span class="mf">2.432</span><span class="p">,</span>    <span class="mf">0.</span>   <span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">float32</span><span class="p">)</span>
</code></pre></div>
<h3 id="12">1.2 模型加载<a class="headerlink" href="#12" title="Permanent link">&para;</a></h3>
<p>加载使用coco数据集预训练的模型，对图像进行预测。</p>
<div class="highlight"><pre><span></span><code><span class="c1"># coco数据集的class，共80个类别：人，自行车，火车，。。。</span>
<span class="n">classes</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;bg&#39;</span><span class="p">,</span> <span class="s1">&#39;person&#39;</span><span class="p">,</span> <span class="s1">&#39;bicycle&#39;</span><span class="p">,</span> <span class="s1">&#39;car&#39;</span><span class="p">,</span> <span class="s1">&#39;motorcycle&#39;</span><span class="p">,</span> <span class="s1">&#39;airplane&#39;</span><span class="p">,</span> <span class="s1">&#39;bus&#39;</span><span class="p">,</span> <span class="s1">&#39;train&#39;</span><span class="p">,</span> <span class="s1">&#39;truck&#39;</span><span class="p">,</span> <span class="s1">&#39;boat&#39;</span><span class="p">,</span> <span class="s1">&#39;traffic light&#39;</span><span class="p">,</span> <span class="s1">&#39;fire hydrant&#39;</span><span class="p">,</span> <span class="s1">&#39;stop sign&#39;</span><span class="p">,</span> <span class="s1">&#39;parking meter&#39;</span><span class="p">,</span> <span class="s1">&#39;bench&#39;</span><span class="p">,</span> <span class="s1">&#39;bird&#39;</span><span class="p">,</span> <span class="s1">&#39;cat&#39;</span><span class="p">,</span> <span class="s1">&#39;dog&#39;</span><span class="p">,</span> <span class="s1">&#39;horse&#39;</span><span class="p">,</span> <span class="s1">&#39;sheep&#39;</span><span class="p">,</span> <span class="s1">&#39;cow&#39;</span><span class="p">,</span> <span class="s1">&#39;elephant&#39;</span><span class="p">,</span> <span class="s1">&#39;bear&#39;</span><span class="p">,</span> <span class="s1">&#39;zebra&#39;</span><span class="p">,</span> <span class="s1">&#39;giraffe&#39;</span><span class="p">,</span> <span class="s1">&#39;backpack&#39;</span><span class="p">,</span> <span class="s1">&#39;umbrella&#39;</span><span class="p">,</span> <span class="s1">&#39;handbag&#39;</span><span class="p">,</span> <span class="s1">&#39;tie&#39;</span><span class="p">,</span> <span class="s1">&#39;suitcase&#39;</span><span class="p">,</span> <span class="s1">&#39;frisbee&#39;</span><span class="p">,</span> <span class="s1">&#39;skis&#39;</span><span class="p">,</span> <span class="s1">&#39;snowboard&#39;</span><span class="p">,</span> <span class="s1">&#39;sports ball&#39;</span><span class="p">,</span> <span class="s1">&#39;kite&#39;</span><span class="p">,</span> <span class="s1">&#39;baseball bat&#39;</span><span class="p">,</span> <span class="s1">&#39;baseball glove&#39;</span><span class="p">,</span> <span class="s1">&#39;skateboard&#39;</span><span class="p">,</span> <span class="s1">&#39;surfboard&#39;</span><span class="p">,</span>
           <span class="s1">&#39;tennis racket&#39;</span><span class="p">,</span> <span class="s1">&#39;bottle&#39;</span><span class="p">,</span> <span class="s1">&#39;wine glass&#39;</span><span class="p">,</span> <span class="s1">&#39;cup&#39;</span><span class="p">,</span> <span class="s1">&#39;fork&#39;</span><span class="p">,</span> <span class="s1">&#39;knife&#39;</span><span class="p">,</span> <span class="s1">&#39;spoon&#39;</span><span class="p">,</span> <span class="s1">&#39;bowl&#39;</span><span class="p">,</span> <span class="s1">&#39;banana&#39;</span><span class="p">,</span> <span class="s1">&#39;apple&#39;</span><span class="p">,</span> <span class="s1">&#39;sandwich&#39;</span><span class="p">,</span> <span class="s1">&#39;orange&#39;</span><span class="p">,</span> <span class="s1">&#39;broccoli&#39;</span><span class="p">,</span> <span class="s1">&#39;carrot&#39;</span><span class="p">,</span> <span class="s1">&#39;hot dog&#39;</span><span class="p">,</span> <span class="s1">&#39;pizza&#39;</span><span class="p">,</span> <span class="s1">&#39;donut&#39;</span><span class="p">,</span> <span class="s1">&#39;cake&#39;</span><span class="p">,</span> <span class="s1">&#39;chair&#39;</span><span class="p">,</span> <span class="s1">&#39;couch&#39;</span><span class="p">,</span> <span class="s1">&#39;potted plant&#39;</span><span class="p">,</span> <span class="s1">&#39;bed&#39;</span><span class="p">,</span> <span class="s1">&#39;dining table&#39;</span><span class="p">,</span> <span class="s1">&#39;toilet&#39;</span><span class="p">,</span> <span class="s1">&#39;tv&#39;</span><span class="p">,</span> <span class="s1">&#39;laptop&#39;</span><span class="p">,</span> <span class="s1">&#39;mouse&#39;</span><span class="p">,</span> <span class="s1">&#39;remote&#39;</span><span class="p">,</span> <span class="s1">&#39;keyboard&#39;</span><span class="p">,</span> <span class="s1">&#39;cell phone&#39;</span><span class="p">,</span> <span class="s1">&#39;microwave&#39;</span><span class="p">,</span> <span class="s1">&#39;oven&#39;</span><span class="p">,</span> <span class="s1">&#39;toaster&#39;</span><span class="p">,</span> <span class="s1">&#39;sink&#39;</span><span class="p">,</span> <span class="s1">&#39;refrigerator&#39;</span><span class="p">,</span> <span class="s1">&#39;book&#39;</span><span class="p">,</span> <span class="s1">&#39;clock&#39;</span><span class="p">,</span> <span class="s1">&#39;vase&#39;</span><span class="p">,</span> <span class="s1">&#39;scissors&#39;</span><span class="p">,</span> <span class="s1">&#39;teddy bear&#39;</span><span class="p">,</span> <span class="s1">&#39;hair drier&#39;</span><span class="p">,</span> <span class="s1">&#39;toothbrush&#39;</span><span class="p">]</span>
</code></pre></div>
<p>实例化faster-RCNN模型：</p>
<div class="highlight"><pre><span></span><code><span class="c1"># 实例化模型</span>
<span class="n">model</span> <span class="o">=</span> <span class="n">faster_rcnn</span><span class="o">.</span><span class="n">FasterRCNN</span><span class="p">(</span><span class="n">num_classes</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">classes</span><span class="p">))</span>
</code></pre></div>
<p>加载预训练模型，由于fasterRCNN不是按照model的子类构建，所以无法通过h5文件直接加载模型结构，我们将结构实例化后，在加载权重获取整个预训练模型。</p>
<div class="highlight"><pre><span></span><code><span class="n">model</span><span class="p">((</span><span class="n">image</span><span class="p">,</span><span class="n">imagemeta</span><span class="p">,</span><span class="n">bbox</span><span class="p">,</span><span class="n">label</span><span class="p">),</span><span class="n">training</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="c1"># 加载训练好的weights</span>
<span class="n">model</span><span class="o">.</span><span class="n">load_weights</span><span class="p">(</span><span class="s2">&quot;weights/faster_rcnn.h5&quot;</span><span class="p">)</span>
</code></pre></div>
<p>通过model.summary()查看网络架构，如下：</p>
<p><img alt="image-20201230114319613" src="../assets/image-20201230114319613.png" /></p>
<h3 id="13">1.3 模型预测过程<a class="headerlink" href="#13" title="Permanent link">&para;</a></h3>
<p>模型的预测分为两部分：RPN生成候选区域和Fast RCNN进行目标的分类与回归</p>
<h4 id="131-rpn">1.3.1 RPN获取候选区域<a class="headerlink" href="#131-rpn" title="Permanent link">&para;</a></h4>
<div class="highlight"><pre><span></span><code><span class="c1"># RPN获取候选区域：输入图像和对应的元信息，输出是候选的位置信息</span>
<span class="n">proposals</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">simple_test_rpn</span><span class="p">(</span><span class="n">image</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">imagemeta</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
</code></pre></div>
<p>候选区域的结果如下所示：对于上述图像共产生1533个候选区域，每个候选区域使用相对于输入网络中图像归一化后的左上角坐标和右下角坐标。</p>
<div class="highlight"><pre><span></span><code>&lt;tf.Tensor: shape=(1533, 4), dtype=float32, numpy=
array([[0.20729761, 0.00852748, 0.748096  , 0.46975034],
       [0.42213044, 0.5887971 , 0.7810232 , 0.9806169 ],
       [0.40125194, 0.4384725 , 0.48458642, 0.47913405],
       ...,
       [0.25977597, 0.435113  , 0.27290097, 0.4483906 ],
       [0.38884488, 0.41798416, 0.41393432, 0.4339822 ],
       [0.5885266 , 0.65331775, 0.62330776, 0.6913476 ]], dtype=float32)&gt;
</code></pre></div>
<p>我们将这些候选区域绘制在图像上，需要获取绝对位置：</p>
<div class="highlight"><pre><span></span><code><span class="c1"># 绘制在图像上(将proposal绘制在图像上)</span>
<span class="n">visualize</span><span class="o">.</span><span class="n">draw_boxes</span><span class="p">(</span><span class="n">rgd_image</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">boxes</span><span class="o">=</span><span class="n">proposals</span><span class="p">[:,:</span><span class="mi">4</span><span class="p">]</span><span class="o">*</span><span class="mi">1216</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</code></pre></div>
<p>如下图所示：</p>
<p><img alt="image-20201230115841096" src="../assets/image-20201230115841096.png" /></p>
<h4 id="132-fastrcnn">1.3.2 FastRCNN进行目标检测<a class="headerlink" href="#132-fastrcnn" title="Permanent link">&para;</a></h4>
<p>我们将获取的候选区域送入到Fast RCNN网络中进行检测：</p>
<div class="highlight"><pre><span></span><code><span class="c1"># rcnn进行预测,得到的是原图像的检测结果：</span>
<span class="c1"># 输入：要检测的送入网络中的图像，图像的元信息，RPN产生的候选区域</span>
<span class="c1"># 输出：目标检测结果：检测框(相对于原图像)，类别，置信度</span>
<span class="n">res</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">simple_test_bboxes</span><span class="p">(</span><span class="n">image</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">imagemeta</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">proposals</span><span class="p">)</span>
</code></pre></div>
<p>res是一个字典，其结果如下所示：rois是目标框，class_ids是所属的类别，scores是置信度。</p>
<div class="highlight"><pre><span></span><code>{&#39;rois&#39;: array([[ 95.65208   ,   8.963474  , 370.8639    , 224.11072   ],
        [ 57.620296  , 226.60101   , 159.39307   , 310.5221    ],
        [ 86.15405   , 323.98065   , 369.12762   , 497.70337   ],
        [ 83.67178   , 170.96815   , 135.69716   , 221.05861   ],
        [ 74.37474   , 327.855     , 210.86298   , 422.48798   ],
        [ 73.24604   ,   0.97371644, 206.86272   ,  47.992523  ],
        [ 63.968616  , 256.5716    , 192.52466   , 365.3871    ],
        [ 67.055145  ,  88.534515  , 137.3221    , 130.74608   ],
        [227.8164    , 291.93015   , 370.9528    , 434.4086    ],
        [147.73048   , 218.15501   , 177.35306   , 260.56738   ],
        [ 82.44483   ,  40.140255  , 133.15623   , 107.72627   ],
        [122.62652   , 239.552     , 141.19394   , 272.06354   ],
        [154.03288   , 115.91441   , 372.5167    , 426.57187   ],
        [218.90562   , 364.88345   , 247.20554   , 419.03842   ],
        [248.15126   , 407.61325   , 373.63068   , 479.57568   ],
        [139.69551   , 248.66753   , 154.51906   , 264.16055   ],
        [212.88734   , 195.23204   , 238.25243   , 209.22202   ]],
       dtype=float32),
 &#39;class_ids&#39;: array([ 1,  1,  1,  1,  1,  1,  1,  1,  1, 46,  1, 46, 61, 46, 57, 45, 40],
       dtype=int32),
 &#39;scores&#39;: array([0.99917287, 0.992269  , 0.99193186, 0.98929125, 0.986894  ,
        0.98671734, 0.98594207, 0.97716457, 0.97271395, 0.97136974,
        0.9637522 , 0.9585419 , 0.9218482 , 0.8920589 , 0.85597926,
        0.81343234, 0.78660023], dtype=float32)}
</code></pre></div>
<p>将检测结果展示在图像上：</p>
<div class="highlight"><pre><span></span><code><span class="c1"># 将检测结果绘制在图像上</span>
<span class="n">visualize</span><span class="o">.</span><span class="n">display_instances</span><span class="p">(</span><span class="n">ori_img</span><span class="p">,</span><span class="n">res</span><span class="p">[</span><span class="s1">&#39;rois&#39;</span><span class="p">],</span><span class="n">res</span><span class="p">[</span><span class="s1">&#39;class_ids&#39;</span><span class="p">],</span><span class="n">classes</span><span class="p">,</span><span class="n">res</span><span class="p">[</span><span class="s1">&#39;scores&#39;</span><span class="p">])</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</code></pre></div>
<p><img alt="image-20201230120850663" src="../assets/image-20201230120850663.png" /></p>
<p>上述我们介绍了Faster RCNN的工作流程并且给大家展示了网络的检测结果。那接下来我们解决以下几个问题：</p>
<p>1、网络中的每一部分是怎么构建，怎么完成相应的功能的？</p>
<p>2、怎么训练fastrcnn网络去完成我们自己的任务？</p>
<p>那接下来我们就解决上述问题。</p>
<h2 id="2">2.模型结构详解<a class="headerlink" href="#2" title="Permanent link">&para;</a></h2>
<p>Faster RCNN的网络结构如下图所示：</p>
<p><img alt="image-20201230141721104" src="../assets/image-20201230141721104.png" /></p>
<p>我们依然将网络分为四部分：</p>
<ul>
<li><strong>Backbone</strong>：Backbone由CNN卷积神经网络构成，常用的是VGG和resnet, 用来提取图像中的特征，获取图像的特征图。该特征图被共享用于后续RPN层生成候选区域和ROIPooling层中。</li>
<li><strong>RPN网络</strong>：RPN网络用于生成候选区域，用于后续的目标检测。</li>
<li><strong>Roi Pooling</strong>: 该部分收集图像的特征图和RPN网络提取的候选区域位置，综合信息后获取固定尺寸的特征，送入后续全连接层判定目标类别和确定目标位置。</li>
<li><strong>目标分类与回归</strong>: 该部分利用ROIpooling输出特征向量计算候选区域的类别，并通过回归获得检测框最终的精确位置。</li>
</ul>
<p>接下来我们就从这四个方面来详细分析fasterRCNN网络的构成，并结合源码理解每一部分实现的功能。</p>
<h3 id="21backbone">2.1backbone<a class="headerlink" href="#21backbone" title="Permanent link">&para;</a></h3>
<p>backbone一般为VGG，ResNet等网络构成，主要进行特征提取，将最后的全连接层舍弃，得到特征图送入后续网络中进行处理。</p>
<p><img alt="image-20201230142854867" src="../assets/image-20201230142854867.png" /></p>
<p>在源码中使用ResNet + FPN 结构来提取特征。与普通的 FasterRCNN 只需要将一个特征图输入到后续网络中不同，由于加入 FPN结构，需要将多个特征图逐个送入到后续网络中，如下图所示：</p>
<p><img alt="image-20201230143003277" src="../assets/image-20201230143003277.png" /></p>
<p>Resnet进行特征提取，FPN结构作用是当前层的特征图会融合未来层的特征进行上采样，并加以利用。因为有了这样一个结构，当前的特征图就可以获取未来层的信息，也就将低阶特征与高阶特征就有机融合起来了，提升检测精度。如下图所示：</p>
<p><img alt="image-20200917160440015" src="../assets/image-20200917160440015.png" /></p>
<p>在这里ResNet和FPN的完整结构如下图所示:Resnet进行特征提取，FPN网络进行特征融合获取多个特征图后，输入到RPN网络中的特征图是[p2,p3,p4,p5,p6] ，而作为后续目标检测网络FastRCNN的输入则是 [p2,p3,p4,p5] 。</p>
<p><img alt="image-20201020141907780" src="../assets/image-20201020141907780.png" /></p>
<p>我们看下源码实现的内容：</p>
<p>1、resnet特征提取的结果</p>
<div class="highlight"><pre><span></span><code><span class="c1"># 使用backbone获取特征图</span>
<span class="n">C2</span><span class="p">,</span><span class="n">C3</span><span class="p">,</span><span class="n">C4</span><span class="p">,</span><span class="n">C5</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">backbone</span><span class="p">(</span><span class="n">image</span><span class="p">,</span><span class="n">training</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</code></pre></div>
<p>C2,C3,C4,C5是resnet进行特征提取的结果，送入网络中图像大小为（1216，1216，3），经过特征提取后特征图的大小为：</p>
<div class="highlight"><pre><span></span><code><span class="c1"># C2.shape:1216/4 </span>
<span class="n">TensorShape</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">304</span><span class="p">,</span> <span class="mi">304</span><span class="p">,</span> <span class="mi">256</span><span class="p">])</span>
<span class="c1"># C3.shape:1216/8</span>
<span class="n">TensorShape</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">152</span><span class="p">,</span> <span class="mi">152</span><span class="p">,</span> <span class="mi">512</span><span class="p">])</span>
<span class="c1"># C4.shape:1216/16</span>
<span class="n">TensorShape</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">76</span><span class="p">,</span> <span class="mi">76</span><span class="p">,</span> <span class="mi">1024</span><span class="p">])</span>
<span class="c1"># C5.shape:1216/32</span>
<span class="n">TensorShape</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">38</span><span class="p">,</span> <span class="mi">38</span><span class="p">,</span> <span class="mi">2048</span><span class="p">])</span>
</code></pre></div>
<p>2、FPN特征融合的结果</p>
<div class="highlight"><pre><span></span><code><span class="c1"># FPN网络融合：C2,C3,C4,C5是resnet提取的特征结果</span>
<span class="n">P2</span><span class="p">,</span><span class="n">P3</span><span class="p">,</span><span class="n">P4</span><span class="p">,</span><span class="n">P5</span><span class="p">,</span><span class="n">P6</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">neck</span><span class="p">([</span><span class="n">C2</span><span class="p">,</span><span class="n">C3</span><span class="p">,</span><span class="n">C4</span><span class="p">,</span><span class="n">C5</span><span class="p">],</span><span class="n">training</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</code></pre></div>
<p>P2,P3,P4,P5,P6是特征融合之后的结果，送入后续网络中，其特征图的大小：</p>
<div class="highlight"><pre><span></span><code><span class="c1"># P2.shape:1216/4 </span>
<span class="n">TensorShape</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">304</span><span class="p">,</span> <span class="mi">304</span><span class="p">,</span> <span class="mi">256</span><span class="p">])</span>
<span class="c1"># P3.shape:1216/8</span>
<span class="n">TensorShape</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">152</span><span class="p">,</span> <span class="mi">152</span><span class="p">,</span> <span class="mi">512</span><span class="p">])</span>
<span class="c1"># P4.shape:1216/16</span>
<span class="n">TensorShape</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">76</span><span class="p">,</span> <span class="mi">76</span><span class="p">,</span> <span class="mi">1024</span><span class="p">])</span>
<span class="c1"># P5.shape:1216/32</span>
<span class="n">TensorShape</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">38</span><span class="p">,</span> <span class="mi">38</span><span class="p">,</span> <span class="mi">2048</span><span class="p">])</span>
<span class="c1"># P6.shape:1216/64</span>
<span class="n">TensorShape</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">19</span><span class="p">,</span> <span class="mi">19</span><span class="p">,</span> <span class="mi">256</span><span class="p">])</span>
</code></pre></div>
<p>那网络的整体架构表示成：</p>
<p><img alt="image-20201020144728158" src="../assets/image-20201020144728158.png" /></p>
<h3 id="22-rpn">2.2 RPN网络<a class="headerlink" href="#22-rpn" title="Permanent link">&para;</a></h3>
<p>经典的检测方法生成检测框都非常耗时，如overfeat中使用滑动窗口生成检测框；或如R-CNN使用选择性搜索方法生成检测框。而Faster RCNN则抛弃了传统的滑动窗口和选择性搜索的方法，直接使用RPN生成候选区域，能极大提升检测速度。</p>
<p><img alt="image-20200914165619471" src="../assets/image-20200914165619471.png" /></p>
<p>RPN网络的主要流程是：</p>
<p>1、生成一系列的固定参考框anchors,覆盖图像的任意位置，然后送入后续网络中进行分类和回归</p>
<p>2、分类分支：通过softmax分类判断anchor中是否包含目标</p>
<p>3、回归分支：计算目标框对于anchors的偏移量，以获得精确的候选区域</p>
<p>4、最后的Proposal层则负责综合含有目标的anchors和对应bbox回归偏移量获取候选区域，同时剔除太小和超出边界的候选区域。</p>
<h4 id="221-anchors">2.2.1 anchors<a class="headerlink" href="#221-anchors" title="Permanent link">&para;</a></h4>
<p>anchor在目标检测中表示 固定的参考框 ，首先预设一组不同尺度不同长宽比的固定参考框，覆盖几乎所有位置， 每个参考框负责检测与其交并比大于阈值 (训练预设值，常用0.5或0.7) 的目标 ，anchor技术将候选区域生成问题转换为 "这个固定参考框中有没有目标，目标框偏离参考框多远" ，不再需要多尺度遍历滑窗，真正实现了又好又快。</p>
<p>在FastRCNN中框出多尺度、多种长宽比的anchors,如下图所示：下图中分别是尺度为32，64，128，长宽比为1：1，1:2，2：1的一组anchors,我们利用这组anchor在特征图上进行滑动，并对应到原图上即可获取一系列的固定参考框。</p>
<p><img alt="image-20201230161949225" src="../assets/image-20201230161949225.png" /></p>
<p>由于有 FPN 网络，所以会在多个不同尺度特征图中生成anchor，假设某一个特征图大小为hxw，首先会计算这个特征相对于输入图像的下采样倍数 stride：</p>
<p><img alt="image-20200917181250070" src="../assets/image-20200917181250070.png" /></p>
<p>如下图所示：</p>
<p><img alt="image-20200917181349548" src="../assets/image-20200917181349548.png" /></p>
<p>每一个尺度特征图上生成不同比列的anchor:</p>
<p><img alt="image-20201230162534596" src="../assets/image-20201230162534596.png" /></p>
<p>得到一系列的anchors后就可送入后续网络中进行分类和回归。</p>
<p>在源码中我们可生成一幅图像对应的anchors: </p>
<div class="highlight"><pre><span></span><code><span class="c1"># 产生anchor：输入图像元信息即可，输出anchor对应于原图的坐标值</span>
<span class="n">anchors</span><span class="p">,</span><span class="n">valid_flags</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">rpn_head</span><span class="o">.</span><span class="n">generator</span><span class="o">.</span><span class="n">generate_pyramid_anchors</span><span class="p">(</span><span class="n">imagemeta</span><span class="p">)</span>
</code></pre></div>
<p>对于1216x1216的图像生成的anchor的数量为：</p>
<div class="highlight"><pre><span></span><code><span class="c1"># anchors.shape：</span>
<span class="c1">#304*304*3+152*152*3+76*76*3+38*38*3+19*19*3=369303</span>
<span class="n">TensorShape</span><span class="p">([</span><span class="mi">369303</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span>
</code></pre></div>
<p>anchor的取值为：</p>
<div class="highlight"><pre><span></span><code><span class="o">&lt;</span><span class="n">tf</span><span class="o">.</span><span class="n">Tensor</span><span class="p">:</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">369303</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">float32</span><span class="p">,</span> <span class="n">numpy</span><span class="o">=</span>
<span class="n">array</span><span class="p">([[</span> <span class="o">-</span><span class="mf">22.627417</span><span class="p">,</span>  <span class="o">-</span><span class="mf">11.313708</span><span class="p">,</span>   <span class="mf">22.627417</span><span class="p">,</span>   <span class="mf">11.313708</span><span class="p">],</span>
       <span class="p">[</span> <span class="o">-</span><span class="mf">16.</span>      <span class="p">,</span>  <span class="o">-</span><span class="mf">16.</span>      <span class="p">,</span>   <span class="mf">16.</span>      <span class="p">,</span>   <span class="mf">16.</span>      <span class="p">],</span>
       <span class="p">[</span> <span class="o">-</span><span class="mf">11.313708</span><span class="p">,</span>  <span class="o">-</span><span class="mf">22.627417</span><span class="p">,</span>   <span class="mf">11.313708</span><span class="p">,</span>   <span class="mf">22.627417</span><span class="p">],</span>
       <span class="o">...</span><span class="p">,</span>
       <span class="p">[</span> <span class="mf">789.9613</span>  <span class="p">,</span>  <span class="mf">970.98065</span> <span class="p">,</span> <span class="mf">1514.0387</span>  <span class="p">,</span> <span class="mf">1333.0193</span>  <span class="p">],</span>
       <span class="p">[</span> <span class="mf">896.</span>      <span class="p">,</span>  <span class="mf">896.</span>      <span class="p">,</span> <span class="mf">1408.</span>      <span class="p">,</span> <span class="mf">1408.</span>      <span class="p">],</span>
       <span class="p">[</span> <span class="mf">970.98065</span> <span class="p">,</span>  <span class="mf">789.9613</span>  <span class="p">,</span> <span class="mf">1333.0193</span>  <span class="p">,</span> <span class="mf">1514.0387</span>  <span class="p">]],</span>
      <span class="n">dtype</span><span class="o">=</span><span class="n">float32</span><span class="p">)</span><span class="o">&gt;</span>
</code></pre></div>
<p>我们将前10000个anchor绘制在图像上：</p>
<div class="highlight"><pre><span></span><code><span class="c1"># 绘制在图像上(将anchor绘制在图像上)</span>
<span class="n">visualize</span><span class="o">.</span><span class="n">draw_boxes</span><span class="p">(</span><span class="n">rgd_image</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">boxes</span><span class="o">=</span><span class="n">anchors</span><span class="p">[:</span><span class="mi">10000</span><span class="p">,:</span><span class="mi">4</span><span class="p">])</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</code></pre></div>
<p><img alt="image-20201230163402232" src="../assets/image-20201230163402232.png" /></p>
<h4 id="222-rpn">2.2.2 RPN分类<a class="headerlink" href="#222-rpn" title="Permanent link">&para;</a></h4>
<p>一副MxN大小的矩阵送入Faster RCNN网络后，经过backbone特征提取到RPN网络变为HxW大小的特征图。如下图所示，是RPN进行分类的网络结构：(k=9)</p>
<p><img alt="image-20200914170316205" src="../assets/image-20200914170316205.png" /></p>
<p>先做一个1x1的卷积，得到[batchsize,H,W,18]的特征图，然后进行变形,将特征图转换为[batchsize,9xH,W,2]的特征图后，送入softmax中进行分类，得到分类结果后，再进行reshape最终得到[batchsize,H,W,18]大小的结果,18表示k=9个anchor是否包含目标的概率值。</p>
<p><img alt="image-20200914170637421" src="../assets/image-20200914170637421.png" /></p>
<h4 id="223-rpn">2.2.3 RPN回归<a class="headerlink" href="#223-rpn" title="Permanent link">&para;</a></h4>
<p>RPN回归的结构如下图所示：(k=9)</p>
<p><img alt="image-20200914173518689" src="../assets/image-20200914173518689.png" /></p>
<p>经过该卷积输出特征图为为[1,  H, W,4x9]，这里相当于feature maps每个点都有9个anchors，每个anchors又都有4个用于回归的:</p>
<p><img alt="image-20200914173617857" src="../assets/image-20200914173617857.png" /></p>
<p>变换量。</p>
<p>该变换量预测的是anchor与真实值之间的平移量和尺度因子：</p>
<p><img alt="image-20200914174033826" src="../assets/image-20200914174033826.png" /></p>
<p>利用源码我们可以获得对anchors的分类和回归结果：</p>
<div class="highlight"><pre><span></span><code><span class="c1"># RPN网络的输入:FPN网络获取的特征图</span>
<span class="n">rpn_feature_maps</span> <span class="o">=</span> <span class="p">[</span><span class="n">P2</span><span class="p">,</span><span class="n">P3</span><span class="p">,</span><span class="n">P4</span><span class="p">,</span><span class="n">P5</span><span class="p">,</span><span class="n">P6</span><span class="p">]</span>
<span class="c1"># RPN网络预测，返回：logits送入softmax之前的分数，包含目标的概率，对框的修正结果</span>
<span class="n">rpn_class_logits</span><span class="p">,</span><span class="n">rpn_probs</span><span class="p">,</span><span class="n">rpn_deltas</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">rpn_head</span><span class="p">(</span><span class="n">rpn_feature_maps</span><span class="p">,</span><span class="n">training</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span>
</code></pre></div>
<p>结果分析：</p>
<div class="highlight"><pre><span></span><code><span class="c1"># rpn_class_logits.shape,每一个anchor都进行了分类分析</span>
<span class="n">TensorShape</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">369303</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="c1"># rpn_probs.shape：softmax输出的概率值</span>
<span class="n">TensorShape</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">369303</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="c1"># rpn_deltas.shape ：回归结果</span>
<span class="n">TensorShape</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">369303</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span>
</code></pre></div>
<p>其中 rpn_probs的取值为：</p>
<div class="highlight"><pre><span></span><code>&lt;tf.Tensor: shape=(1, 369303, 2), dtype=float32, numpy=
array([[[9.94552910e-01, 5.44707105e-03],
        [9.97310877e-01, 2.68914248e-03],
        [9.95540321e-01, 4.45961533e-03],
        ...,
        [9.99888301e-01, 1.11637215e-04],
        [9.99961257e-01, 3.87872169e-05],
        [9.99820888e-01, 1.79159630e-04]]], dtype=float32)&gt;
</code></pre></div>
<p>我们获取一些分类置信度较高的结果，将这些anchor绘制在图像上：</p>
<div class="highlight"><pre><span></span><code><span class="c1"># 获取分类结果中包含目标的概率值</span>
<span class="n">rpn_probs_tmp</span> <span class="o">=</span> <span class="n">rpn_probs</span><span class="p">[</span><span class="mi">0</span><span class="p">,:,</span><span class="mi">1</span><span class="p">]</span>
<span class="c1"># 获取前100个较高的anchor</span>
<span class="n">limit</span> <span class="o">=</span> <span class="mi">100</span>
<span class="n">ix</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">top_k</span><span class="p">(</span><span class="n">rpn_probs_tmp</span><span class="p">,</span><span class="n">k</span><span class="o">=</span><span class="n">limit</span><span class="p">)</span><span class="o">.</span><span class="n">indices</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<span class="c1"># 获取对应的anchor绘制图像上，那这些anchor就有很大概率生成候选区域</span>
<span class="n">visualize</span><span class="o">.</span><span class="n">draw_boxes</span><span class="p">(</span><span class="n">rgd_image</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">tf</span><span class="o">.</span><span class="n">gather</span><span class="p">(</span><span class="n">anchors</span><span class="p">,</span><span class="n">ix</span><span class="p">)</span><span class="o">.</span><span class="n">numpy</span><span class="p">())</span>
</code></pre></div>
<p><img alt="image-20201230165534951" src="../assets/image-20201230165534951.png" /></p>
<h4 id="424-proposal">4.2.4 Proposal层<a class="headerlink" href="#424-proposal" title="Permanent link">&para;</a></h4>
<p>Proposal层负责综合RPN网络对anchors分类和回归的结果，利用回归的结果对包含目标的anchors进行修正，计算出候选区域，送入后续RoI Pooling层中。</p>
<p>Proposal层处理流程如下：</p>
<ol>
<li>利用RPN网络回归的结果<img alt="[公式]" src="https://www.zhihu.com/equation?tex=%5Bd_%7Bx%7D%28A%29%2Cd_%7By%7D%28A%29%2Cd_%7Bw%7D%28A%29%2Cd_%7Bh%7D%28A%29%5D" />对所有的anchors进行修正，得到修正后的检测框</li>
<li>根据RPN网络分类的softmax输出的概率值由大到小对检测框进行排序，提取前6000个结果，即提取修正位置后的检测框</li>
<li>限定超出图像边界的检测框为图像边界，防止后续roi pooling时候选区域超出图像边界。</li>
</ol>
<p><img alt="image-20200914174724293" src="../assets/image-20200914174724293.png" /></p>
<ol>
<li>
<p>对剩余的检测框进行非极大值抑制NMS</p>
</li>
<li>
<p>Proposal层的输出是对应输入网络图像尺度的归一化后的坐标值[x1, y1, x2, y2]。</p>
</li>
</ol>
<p>到此RPN网络的工作就结束了。</p>
<p>Proposal层有3个输入：RPN分类和回归结果，以及图像的元信息。</p>
<div class="highlight"><pre><span></span><code><span class="c1"># 获取候选区域</span>
<span class="n">proposals_list</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">rpn_head</span><span class="o">.</span><span class="n">get_proposals</span><span class="p">(</span><span class="n">rpn_probs</span><span class="p">,</span><span class="n">rpn_deltas</span><span class="p">,</span><span class="n">imagemeta</span><span class="p">)</span>
</code></pre></div>
<p>结果为：</p>
<div class="highlight"><pre><span></span><code><span class="p">[</span><span class="o">&lt;</span><span class="n">tf</span><span class="o">.</span><span class="n">Tensor</span><span class="p">:</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">1533</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">float32</span><span class="p">,</span> <span class="n">numpy</span><span class="o">=</span>
 <span class="n">array</span><span class="p">([[</span><span class="mf">0.20729761</span><span class="p">,</span> <span class="mf">0.00852748</span><span class="p">,</span> <span class="mf">0.748096</span>  <span class="p">,</span> <span class="mf">0.46975034</span><span class="p">],</span>
        <span class="p">[</span><span class="mf">0.42213044</span><span class="p">,</span> <span class="mf">0.5887971</span> <span class="p">,</span> <span class="mf">0.7810232</span> <span class="p">,</span> <span class="mf">0.9806169</span> <span class="p">],</span>
        <span class="p">[</span><span class="mf">0.40125194</span><span class="p">,</span> <span class="mf">0.4384725</span> <span class="p">,</span> <span class="mf">0.48458642</span><span class="p">,</span> <span class="mf">0.47913405</span><span class="p">],</span>
        <span class="o">...</span><span class="p">,</span>
        <span class="p">[</span><span class="mf">0.25977597</span><span class="p">,</span> <span class="mf">0.435113</span>  <span class="p">,</span> <span class="mf">0.27290097</span><span class="p">,</span> <span class="mf">0.4483906</span> <span class="p">],</span>
        <span class="p">[</span><span class="mf">0.38884488</span><span class="p">,</span> <span class="mf">0.41798416</span><span class="p">,</span> <span class="mf">0.41393432</span><span class="p">,</span> <span class="mf">0.4339822</span> <span class="p">],</span>
        <span class="p">[</span><span class="mf">0.5885266</span> <span class="p">,</span> <span class="mf">0.65331775</span><span class="p">,</span> <span class="mf">0.62330776</span><span class="p">,</span> <span class="mf">0.6913476</span> <span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">float32</span><span class="p">)</span><span class="o">&gt;</span><span class="p">]</span>
</code></pre></div>
<p>将其绘制在图像上</p>
<div class="highlight"><pre><span></span><code><span class="c1"># 绘制在图像上(将proposal绘制在图像上)</span>
<span class="n">visualize</span><span class="o">.</span><span class="n">draw_boxes</span><span class="p">(</span><span class="n">rgd_image</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">boxes</span><span class="o">=</span><span class="n">proposals_list</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">numpy</span><span class="p">()[:,:</span><span class="mi">4</span><span class="p">]</span><span class="o">*</span><span class="mi">1216</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</code></pre></div>
<p><img alt="image-20201230171056236" src="../assets/image-20201230171056236.png" /></p>
<h3 id="23-roipooling">2.3 ROIPooling<a class="headerlink" href="#23-roipooling" title="Permanent link">&para;</a></h3>
<p>RoI Pooling层则负责收集RPN网络生成的候选区域，并将其映射到特征图中并固定维度，送入后续网络中进行分类和回归。</p>
<p><img alt="image-20201021100152187" src="../assets/image-20201021100152187.png" /></p>
<p>RoI Pooling 的作用过程，如下图所示：</p>
<p><img alt="image-20201021101351332" src="../assets/image-20201021101351332.png" /></p>
<p>RoIpooling使用最大池化将任何有效的RoI区域内的特征转换成具有pool_H×pool_W的固定空间范围的小的特征图，其中pool_H和pool_W是超参数，比如设置为7x7, 它们独立于任何特定的RoI,如下图所示：</p>
<p><img alt="image-20201021100421465" src="../assets/image-20201021100421465.png" /></p>
<p>在实现过程中，FPN网络产生了多个尺度特征图，那候选区域要映射到哪个特征图中呢？</p>
<p><img alt="image-20201021101441266" src="../assets/image-20201021101441266.png" /></p>
<p>在这里，不同尺度的ROI使用不同特征层作为ROI pooling层的输入，大尺度ROI就用后面一些的金字塔层，比如P5；小尺度ROI就用前面一点的特征层，比如P3，我们使用下面的公式确定ROI所在的特征层：</p>
<p><img alt="image-20201021102107570" src="../assets/image-20201021102107570.png" /></p>
<p>其中，224是ImageNet的标准输入，k0是基准值，设置为4，w和h是ROI区域的长和宽，假设ROI是112x112的大小，那么k = k0-1 = 4-1 = 3，意味着该ROI应该使用P3的特征层。k值会做取整处理，防止结果不是整数，而且为了保证k值在2-5之间，还会做截断处理。 </p>
<div class="highlight"><pre><span></span><code><span class="c1"># ROI Pooling层实现:输入是候选区域，特征图，图像的元信息</span>
<span class="n">pool_region_list</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">roi_align</span><span class="p">((</span><span class="n">proposals_list</span><span class="p">,</span><span class="n">rcnn_feature_maps</span><span class="p">,</span><span class="n">imagemeta</span><span class="p">),</span><span class="n">training</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span>
</code></pre></div>
<p>输出结果为：每一个候选区域都被固定为7x7大小</p>
<div class="highlight"><pre><span></span><code><span class="p">[</span><span class="o">&lt;</span><span class="n">tf</span><span class="o">.</span><span class="n">Tensor</span><span class="p">:</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">1533</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">256</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">float32</span><span class="p">,</span> <span class="n">numpy</span><span class="o">=</span>
 <span class="n">array</span><span class="p">([[[[</span><span class="o">-</span><span class="mf">6.26428795e+00</span><span class="p">,</span>  <span class="mf">3.55317879e+00</span><span class="p">,</span>  <span class="mf">3.37260556e+00</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span>
            <span class="mf">6.22574663e+00</span><span class="p">,</span>  <span class="mf">3.75851846e+00</span><span class="p">,</span> <span class="o">-</span><span class="mf">2.49103808e+00</span><span class="p">],</span>
          <span class="p">[</span><span class="o">-</span><span class="mf">9.01443863e+00</span><span class="p">,</span>  <span class="mf">7.67611027e-01</span><span class="p">,</span>  <span class="mf">7.18744850e+00</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span>
            <span class="mf">6.20492172e+00</span><span class="p">,</span>  <span class="mf">4.09835625e+00</span><span class="p">,</span>  <span class="mf">6.05924249e-01</span><span class="p">],</span>
          <span class="p">[</span><span class="o">-</span><span class="mf">7.43907213e+00</span><span class="p">,</span> <span class="o">-</span><span class="mf">3.76329374e+00</span><span class="p">,</span>  <span class="mf">5.01457691e+00</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span>
            <span class="mf">6.22656918e+00</span><span class="p">,</span>  <span class="mf">1.19414163e+00</span><span class="p">,</span>  <span class="mf">3.06410480e+00</span><span class="p">],</span>
          <span class="o">...</span><span class="p">,</span>
          <span class="p">[</span> <span class="mf">1.39127302e+00</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.71078873e+00</span><span class="p">,</span>  <span class="mf">4.01916075e+00</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span>
            <span class="mf">5.94641972e+00</span><span class="p">,</span>  <span class="mf">3.63194764e-01</span><span class="p">,</span>  <span class="mf">2.91014194e+00</span><span class="p">],</span>
          <span class="p">[</span><span class="o">-</span><span class="mf">5.21681070e+00</span><span class="p">,</span>  <span class="mf">2.39917469e+00</span><span class="p">,</span>  <span class="mf">2.49682212e+00</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span>
            <span class="mf">5.92232943e+00</span><span class="p">,</span>  <span class="mf">3.01222801e+00</span><span class="p">,</span>  <span class="mf">1.63518691e+00</span><span class="p">],</span>
          <span class="p">[</span><span class="o">-</span><span class="mf">1.26697767e+00</span><span class="p">,</span> <span class="o">-</span><span class="mf">6.90211892e-01</span><span class="p">,</span>  <span class="mf">4.50919747e-01</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span>
            <span class="mf">1.97156405e+00</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.07467103e+00</span><span class="p">,</span>  <span class="mf">4.54943466e+00</span><span class="p">]]</span>
</code></pre></div>
<h3 id="24">2.4 目标分类与回归<a class="headerlink" href="#24" title="Permanent link">&para;</a></h3>
<p>该部分利用获得的候选区域的特征图，通过全连接层与softmax计算每个候选区域具体属于的类别（如人，车，电视等），输出概率值；同时再次利用回归方法获得每个候选区域的位置偏移量，用于回归更加精确的目标检测框。该部分网络结构如下所示：</p>
<p><img alt="image-20200914175906233" src="../assets/image-20200914175906233.png" /></p>
<p>从RoI Pooling层获取到固定大小的特征图后，送入后续网络，可以看到做了如下2件事：</p>
<ol>
<li>通过全连接和softmax对候选区域进行分类</li>
<li>再次对候选区域进行回归修正，获取更高精度的检测框</li>
</ol>
<p>实现流程如下：</p>
<p>首先获取网络分类和回归的结果：</p>
<div class="highlight"><pre><span></span><code><span class="c1"># RCNN网络的预测:输入是ROIPooling层的特征，输出：类别的score,类别的概率值，回归结果</span>
<span class="n">rcnn_class_logits</span><span class="p">,</span><span class="n">rcnn_class_probs</span><span class="p">,</span><span class="n">rcnn_deltas_list</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">bbox_head</span><span class="p">(</span><span class="n">pool_region_list</span><span class="p">,</span><span class="n">training</span><span class="o">=</span><span class="kc">False</span><span class="err">）</span>
</code></pre></div>
<p>利用结果对候选区域进行修正：</p>
<div class="highlight"><pre><span></span><code><span class="c1"># 获取预测结果:输入：rcnn返回的分类和回归结果，候选区域，图像元信息，输出：目标检测结果</span>
<span class="n">detection_list</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">bbox_head</span><span class="o">.</span><span class="n">get_bboxes</span><span class="p">(</span><span class="n">rcnn_class_probs</span><span class="p">,</span><span class="n">rcnn_deltas_list</span><span class="p">,</span><span class="n">proposals_list</span><span class="p">,</span><span class="n">imagemeta</span><span class="p">)</span>
</code></pre></div>
<p>结果为：一共检测出17个目标，每个目标右目标位置，目标类别id，目标类别置信度6个值构成。</p>
<div class="highlight"><pre><span></span><code><span class="p">[</span><span class="o">&lt;</span><span class="n">tf</span><span class="o">.</span><span class="n">Tensor</span><span class="p">:</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">17</span><span class="p">,</span> <span class="mi">6</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">float32</span><span class="p">,</span> <span class="n">numpy</span><span class="o">=</span>
 <span class="n">array</span><span class="p">([[</span><span class="mf">2.3262584e+02</span><span class="p">,</span> <span class="mf">2.1799168e+01</span><span class="p">,</span> <span class="mf">9.0194098e+02</span><span class="p">,</span> <span class="mf">5.4503723e+02</span><span class="p">,</span>
         <span class="mf">1.0000000e+00</span><span class="p">,</span> <span class="mf">9.9917287e-01</span><span class="p">],</span>
        <span class="p">[</span><span class="mf">1.4013255e+02</span><span class="p">,</span> <span class="mf">5.5109363e+02</span><span class="p">,</span> <span class="mf">3.8764392e+02</span><span class="p">,</span> <span class="mf">7.5518970e+02</span><span class="p">,</span>
         <span class="mf">1.0000000e+00</span><span class="p">,</span> <span class="mf">9.9226898e-01</span><span class="p">],</span>
        <span class="p">[</span><span class="mf">2.0952664e+02</span><span class="p">,</span> <span class="mf">7.8792090e+02</span><span class="p">,</span> <span class="mf">8.9771838e+02</span><span class="p">,</span> <span class="mf">1.2104146e+03</span><span class="p">,</span>
         <span class="mf">1.0000000e+00</span><span class="p">,</span> <span class="mf">9.9193186e-01</span><span class="p">],</span>
        <span class="p">[</span><span class="mf">2.0348978e+02</span><span class="p">,</span> <span class="mf">4.1579453e+02</span><span class="p">,</span> <span class="mf">3.3001547e+02</span><span class="p">,</span> <span class="mf">5.3761450e+02</span><span class="p">,</span>
         <span class="mf">1.0000000e+00</span><span class="p">,</span> <span class="mf">9.8929125e-01</span><span class="p">],</span>
        <span class="p">[</span><span class="mf">1.8087936e+02</span><span class="p">,</span> <span class="mf">7.9734338e+02</span><span class="p">,</span> <span class="mf">5.1281873e+02</span><span class="p">,</span> <span class="mf">1.0274907e+03</span><span class="p">,</span>
         <span class="mf">1.0000000e+00</span><span class="p">,</span> <span class="mf">9.8689401e-01</span><span class="p">],</span>
        <span class="p">[</span><span class="mf">1.7813437e+02</span><span class="p">,</span> <span class="mf">2.3680782e+00</span><span class="p">,</span> <span class="mf">5.0309012e+02</span><span class="p">,</span> <span class="mf">1.1671781e+02</span><span class="p">,</span>
         <span class="mf">1.0000000e+00</span><span class="p">,</span> <span class="mf">9.8671734e-01</span><span class="p">],</span>
        <span class="p">[</span><span class="mf">1.5557167e+02</span><span class="p">,</span> <span class="mf">6.2398212e+02</span><span class="p">,</span> <span class="mf">4.6821997e+02</span><span class="p">,</span> <span class="mf">8.8862134e+02</span><span class="p">,</span>
         <span class="mf">1.0000000e+00</span><span class="p">,</span> <span class="mf">9.8594207e-01</span><span class="p">],</span>
        <span class="p">[</span><span class="mf">1.6307811e+02</span><span class="p">,</span> <span class="mf">2.1531593e+02</span><span class="p">,</span> <span class="mf">3.3396735e+02</span><span class="p">,</span> <span class="mf">3.1797446e+02</span><span class="p">,</span>
         <span class="mf">1.0000000e+00</span><span class="p">,</span> <span class="mf">9.7716457e-01</span><span class="p">],</span>
        <span class="p">[</span><span class="mf">5.5404950e+02</span><span class="p">,</span> <span class="mf">7.0997412e+02</span><span class="p">,</span> <span class="mf">9.0215717e+02</span><span class="p">,</span> <span class="mf">1.0564817e+03</span><span class="p">,</span>
         <span class="mf">1.0000000e+00</span><span class="p">,</span> <span class="mf">9.7271395e-01</span><span class="p">],</span>
        <span class="p">[</span><span class="mf">3.5928052e+02</span><span class="p">,</span> <span class="mf">5.3055298e+02</span><span class="p">,</span> <span class="mf">4.3132263e+02</span><span class="p">,</span> <span class="mf">6.3369983e+02</span><span class="p">,</span>
         <span class="mf">4.6000000e+01</span><span class="p">,</span> <span class="mf">9.7136974e-01</span><span class="p">],</span>
        <span class="p">[</span><span class="mf">2.0050583e+02</span><span class="p">,</span> <span class="mf">9.7621101e+01</span><span class="p">,</span> <span class="mf">3.2383597e+02</span><span class="p">,</span> <span class="mf">2.6199030e+02</span><span class="p">,</span>
         <span class="mf">1.0000000e+00</span><span class="p">,</span> <span class="mf">9.6375221e-01</span><span class="p">],</span>
        <span class="p">[</span><span class="mf">2.9822769e+02</span><span class="p">,</span> <span class="mf">5.8259045e+02</span><span class="p">,</span> <span class="mf">3.4338364e+02</span><span class="p">,</span> <span class="mf">6.6165851e+02</span><span class="p">,</span>
         <span class="mf">4.6000000e+01</span><span class="p">,</span> <span class="mf">9.5854193e-01</span><span class="p">],</span>
        <span class="p">[</span><span class="mf">3.7460797e+02</span><span class="p">,</span> <span class="mf">2.8190384e+02</span><span class="p">,</span> <span class="mf">9.0596057e+02</span><span class="p">,</span> <span class="mf">1.0374227e+03</span><span class="p">,</span>
         <span class="mf">6.1000000e+01</span><span class="p">,</span> <span class="mf">9.2184818e-01</span><span class="p">],</span>
        <span class="p">[</span><span class="mf">5.3237848e+02</span><span class="p">,</span> <span class="mf">8.8739655e+02</span><span class="p">,</span> <span class="mf">6.0120386e+02</span><span class="p">,</span> <span class="mf">1.0191014e+03</span><span class="p">,</span>
         <span class="mf">4.6000000e+01</span><span class="p">,</span> <span class="mf">8.9205891e-01</span><span class="p">],</span>
        <span class="p">[</span><span class="mf">6.0350385e+02</span><span class="p">,</span> <span class="mf">9.9131537e+02</span><span class="p">,</span> <span class="mf">9.0866974e+02</span><span class="p">,</span> <span class="mf">1.1663280e+03</span><span class="p">,</span>
         <span class="mf">5.7000000e+01</span><span class="p">,</span> <span class="mf">8.5597926e-01</span><span class="p">],</span>
        <span class="p">[</span><span class="mf">3.3973947e+02</span><span class="p">,</span> <span class="mf">6.0475940e+02</span><span class="p">,</span> <span class="mf">3.7579034e+02</span><span class="p">,</span> <span class="mf">6.4243842e+02</span><span class="p">,</span>
         <span class="mf">4.5000000e+01</span><span class="p">,</span> <span class="mf">8.1343234e-01</span><span class="p">],</span>
        <span class="p">[</span><span class="mf">5.1774200e+02</span><span class="p">,</span> <span class="mf">4.7480432e+02</span><span class="p">,</span> <span class="mf">5.7942987e+02</span><span class="p">,</span> <span class="mf">5.0882794e+02</span><span class="p">,</span>
         <span class="mf">4.0000000e+01</span><span class="p">,</span> <span class="mf">7.8660023e-01</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">float32</span><span class="p">)</span><span class="o">&gt;</span><span class="p">]</span>
</code></pre></div>
<p>可以将其绘制在图像上：</p>
<div class="highlight"><pre><span></span><code><span class="c1"># 绘制在图像上</span>
<span class="n">visualize</span><span class="o">.</span><span class="n">draw_boxes</span><span class="p">(</span><span class="n">rgd_image</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">boxes</span><span class="o">=</span><span class="n">detection_list</span><span class="p">[</span><span class="mi">0</span><span class="p">][:,:</span><span class="mi">4</span><span class="p">])</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">(</span><span class="err">）</span>
</code></pre></div>
<p><img alt="image-20201230173439116" src="../assets/image-20201230173439116.png" /></p>
<p>到这我们就完成了整个网络的介绍。</p>
<h2 id="3-fasterrcnn">3 FasterRCNN的训练<a class="headerlink" href="#3-fasterrcnn" title="Permanent link">&para;</a></h2>
<p>Faster R-CNN的训练分为两部分，即RPN网络和检测网络fastRCNN的训练：</p>
<p><img alt="image-20200914180529313" src="../assets/image-20200914180529313.png" /></p>
<p>整个训练过程分为四步：</p>
<ul>
<li>第一步：RPN网络的训练，使用ImageNet预训练的模型初始化，并端到端微调用于区域建议任务。</li>
<li>第二步：利用第一步的RPN生成的建议框，由Fast R-CNN训练一个单独的检测网络，这个检测网络同样是由ImageNet预训练的模型初始化的，这时候两个网络还没有共享卷积层。</li>
<li>第三步：用检测网络初始化RPN训练，但是固定共享的卷积层，并且只微调RPN独有的层，现在两个网络共享卷积层了。</li>
<li>第四步：保持共享的卷积层固定，微调Fast R-CNN的fc层。这样，两个网络共享相同的卷积层，构成一个统一的网络。</li>
</ul>
<p><img alt="image-20200914180732315" src="../assets/image-20200914180732315.png" /></p>
<p>接下来我们分别介绍各个训练步骤：</p>
<h3 id="31-rpn">3.1 RPN网络的训练<a class="headerlink" href="#31-rpn" title="Permanent link">&para;</a></h3>
<p>RPN网络的作用从众多的anchors中提取包含目标的，并且经过回归调整的候选区域。为了训练RPN，给每个anchor分配是否包含目标的标签，也就是正负样本的标记，然后进行训练。</p>
<h4 id="311">3.1.1正负样本标记<a class="headerlink" href="#311" title="Permanent link">&para;</a></h4>
<ul>
<li>与真实框ground truth（GT）交并比IOU大于0.7的anchor是正样本，即anchor中包含目标，目标值设为1</li>
<li>与真实框ground truth（GT）交并比IOU小于0.3的anchor是负样本，即anchor中不包含目标，目标值设为-1</li>
<li>其他的anchor舍弃，不参与网络的训练，目标值设为0</li>
</ul>
<h4 id="312-rpn">3.1.2 RPN网络的损失函数<a class="headerlink" href="#312-rpn" title="Permanent link">&para;</a></h4>
<p>RPN网络的损失函数是：</p>
<p><img alt="image-20200915095837059" src="../assets/image-20200915095837059.png" /></p>
<p>其中</p>
<ul>
<li>
<p><span><span class="MathJax_Preview">i</span><script type="math/tex">i</script></span>表示anchor的索引</p>
</li>
<li>
<p><span><span class="MathJax_Preview">p_i</span><script type="math/tex">p_i</script></span>是第i个anchor 预测为目标的可能性，<span><span class="MathJax_Preview">p_i^{*}</span><script type="math/tex">p_i^{*}</script></span>为ground-truth标签。如果这个anchor是positive的，则ground-truth标签为1，否则为0。（即当第i个anchor与GT间IoU&gt;0.7，认为是该anchor是positive，标签为1；反之IoU&lt;0.3时，认为是该anchor是negative，标签为0）</p>
</li>
<li>
<p><span><span class="MathJax_Preview">t_i</span><script type="math/tex">t_i</script></span>表示表示正样本anchor到预测区域bounding box的4个参数化预测结果,<span><span class="MathJax_Preview">t_i^{*}</span><script type="math/tex">t_i^{*}</script></span>是这个positive anchor对应的ground-truth box的偏移，如下所示：</p>
</li>
</ul>
<p>预测值：</p>
<p><img alt="image-20200915101257709" src="../assets/image-20200915101257709.png" /></p>
<p>真实值：</p>
<p><img alt="image-20200915101314285" src="../assets/image-20200915101314285.png" /></p>
<p>其中，x，y，w，h表示窗口中心坐标和窗口的宽度和高度，变量x， <span><span class="MathJax_Preview">x_a 和x^{*}</span><script type="math/tex">x_a 和x^{*}</script></span> 分别表示预测窗口、anchor窗口和Ground Truth的坐标（y，w，h同理）</p>
<p>整个Loss分为两部分：分类和回归的损失</p>
<ul>
<li><span><span class="MathJax_Preview">L_{cls}</span><script type="math/tex">L_{cls}</script></span>分类的损失（classification loss），是一个二分类器的softmax loss。</li>
</ul>
<p><img alt="image-20200915100858122" src="../assets/image-20200915100858122.png" /></p>
<ul>
<li><span><span class="MathJax_Preview">L_{reg}</span><script type="math/tex">L_{reg}</script></span>是回归损失，为<span><span class="MathJax_Preview">smooth(x)</span><script type="math/tex">smooth(x)</script></span>损失,并且只有正样本才参与回归损失计算</li>
</ul>
<p><img alt="image-20200915100839788" src="../assets/image-20200915100839788.png" /></p>
<ul>
<li><span><span class="MathJax_Preview">N_{cls}</span><script type="math/tex">N_{cls}</script></span>和<span><span class="MathJax_Preview">N_{reg}</span><script type="math/tex">N_{reg}</script></span>分别用来标准化分类损失项<span><span class="MathJax_Preview">L_{cls}</span><script type="math/tex">L_{cls}</script></span>和回归损失项<span><span class="MathJax_Preview">L_{reg}</span><script type="math/tex">L_{reg}</script></span>，默认用batch size设置<span><span class="MathJax_Preview">N_{cls}</span><script type="math/tex">N_{cls}</script></span>，用anchor位置数目~2000初始化<span><span class="MathJax_Preview">N_{reg}</span><script type="math/tex">N_{reg}</script></span></li>
<li><span><span class="MathJax_Preview">N_{cls}</span><script type="math/tex">N_{cls}</script></span>和<span><span class="MathJax_Preview">N_{reg}</span><script type="math/tex">N_{reg}</script></span>相差过大，用参数λ来平衡两者，一般取值为<span><span class="MathJax_Preview">N_{reg}</span><script type="math/tex">N_{reg}</script></span>和<span><span class="MathJax_Preview">N_{cls}</span><script type="math/tex">N_{cls}</script></span>的比值10即可。</li>
</ul>
<h4 id="313">3.1.3 训练过程<a class="headerlink" href="#313" title="Permanent link">&para;</a></h4>
<p>在训练时每次迭代的正负样本是由一幅图像的正负样本组成的：</p>
<ul>
<li>随机采样256个anchor，计算损失函数，其中采样的正负anchor的比例是1:1。</li>
<li>通过从零均值标准差为0.01的高斯分布中获取的权重来随机初始化所有新层（最后一个卷积层其后的层），所有其他层（即共享的卷积层）是通过对ImageNet分类预训练的模型来初始化的</li>
<li>采用带动量的随机梯度下降算法对网络进行训练</li>
</ul>
<h4 id="314">3.1.4 实现<a class="headerlink" href="#314" title="Permanent link">&para;</a></h4>
<h5 id="1_1">1、正负样本设置<a class="headerlink" href="#1_1" title="Permanent link">&para;</a></h5>
<p>将产生的369303个anchor与目标真实值的计算交并比设置正负样本：</p>
<div class="highlight"><pre><span></span><code><span class="c1"># 获取对应的目标值：输入：要设置正负样本的anchors，anchor在有效区域的标识，样本标记的bbox及类别label；输出：rpn的分类目标值，RPN的回归目标值</span>
<span class="n">rpn_target_matchs</span><span class="p">,</span><span class="n">rpn_target_deltas</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">rpn_head</span><span class="o">.</span><span class="n">anchor_target</span><span class="o">.</span><span class="n">build_targets</span><span class="p">(</span><span class="n">anchors</span><span class="p">,</span><span class="n">valid_flags</span><span class="p">,</span><span class="n">bbox</span><span class="p">,</span><span class="n">label</span><span class="p">)</span>
</code></pre></div>
<p>所有的anchor都设置了分类的目标值，回归的目标值只有正负样本设置了目标值，一共有369303个Anchor，参与训练的有256个anchor。</p>
<div class="highlight"><pre><span></span><code><span class="c1"># rpn_target_matchs.shape</span>
<span class="n">TensorShape</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">369303</span><span class="p">])</span>
<span class="c1"># rpn_target_deltas.shape</span>
<span class="n">TensorShape</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">256</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span>
</code></pre></div>
<p>获取正样本：正样本是包含目标的anchor，其目标值设为1，正样本的个数是29个</p>
<div class="highlight"><pre><span></span><code><span class="c1"># 属于正样本的anchors，与GT交并比较大的anchor,目标值设为1</span>
<span class="n">positive_anchors</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">gather</span><span class="p">(</span><span class="n">anchors</span><span class="p">,</span><span class="n">tf</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">tf</span><span class="o">.</span><span class="n">equal</span><span class="p">(</span><span class="n">rpn_target_matchs</span><span class="p">,</span><span class="mi">1</span><span class="p">))[:,</span><span class="mi">1</span><span class="p">])</span>
<span class="c1"># 正样本的个数：一共使用29个属于正样本的anchor</span>
<span class="n">TensorShape</span><span class="p">([</span><span class="mi">29</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span>
</code></pre></div>
<p>我们将这些正样本绘制在图像上：可以看出这些anchor与目标还是非常接近的</p>
<p><img alt="image-20201231095921098" src="../assets/image-20201231095921098.png" /></p>
<p>接下来，我们看下负样本的结果，负样本的目标值是-1，负样本的个数是227，与29个正样本一共是256个anchor参与网络训练，其余的不参与网络训练。</p>
<div class="highlight"><pre><span></span><code><span class="c1"># 负样本</span>
<span class="n">negtivate_anchors</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">gather</span><span class="p">(</span><span class="n">anchors</span><span class="p">,</span><span class="n">tf</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">tf</span><span class="o">.</span><span class="n">equal</span><span class="p">(</span><span class="n">rpn_target_matchs</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">))[:,</span><span class="mi">1</span><span class="p">])</span>
<span class="c1"># negtivate_anchors.shape</span>
<span class="n">TensorShape</span><span class="p">([</span><span class="mi">227</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span>
</code></pre></div>
<p>同样我们也将负样本展示在图像上，从图像可以看出这些负样本的anchor与目标差距还是很大的。</p>
<p><img alt="image-20201231100516539" src="../assets/image-20201231100516539.png" /></p>
<h5 id="2_1">2、损失函数<a class="headerlink" href="#2_1" title="Permanent link">&para;</a></h5>
<p>损失函数计算是将网络预测结果和真实值进行比较，获取两者之间的差别。损失函数由两部分组成：分类和回归</p>
<div class="highlight"><pre><span></span><code><span class="c1"># RPN网络的损失函数</span>
<span class="c1"># 输入：rpn的分类结果rpn_class_logits，rpn的回归结果，bbox标注框，label是目标累呗，imagemera图像元信息</span>
<span class="c1"># 输出：分类损失和回归损失</span>
<span class="n">rpn_class_loss</span><span class="p">,</span> <span class="n">rpn_bbox_loss</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">rpn_head</span><span class="o">.</span><span class="n">loss</span><span class="p">(</span>
                <span class="n">rpn_class_logits</span><span class="p">,</span> <span class="n">rpn_deltas</span><span class="p">,</span> <span class="n">bbox</span><span class="p">,</span> <span class="n">label</span><span class="p">,</span> <span class="n">imagemeta</span><span class="p">)</span>
<span class="c1"># 分类损失：rpn_bbox_loss</span>
<span class="o">&lt;</span><span class="n">tf</span><span class="o">.</span><span class="n">Tensor</span><span class="p">:</span> <span class="n">shape</span><span class="o">=</span><span class="p">(),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">float32</span><span class="p">,</span> <span class="n">numpy</span><span class="o">=</span><span class="mf">0.20614956</span><span class="o">&gt;</span>
<span class="c1"># 回归损失：rpn_class_loss</span>
<span class="o">&lt;</span><span class="n">tf</span><span class="o">.</span><span class="n">Tensor</span><span class="p">:</span> <span class="n">shape</span><span class="o">=</span><span class="p">(),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">float32</span><span class="p">,</span> <span class="n">numpy</span><span class="o">=</span><span class="mf">0.034301624</span><span class="o">&gt;</span>
</code></pre></div>
<p>接下来我们使用梯度下降算法对网络进行训练就可以了</p>
<h3 id="32-fastrcnn">3.2 FastRCNN网络的训练<a class="headerlink" href="#32-fastrcnn" title="Permanent link">&para;</a></h3>
<p>使用RPN网络收集到的候选区域和imageNet预训练的卷积网络提取的特征对检测的FastRCNN网络进行训练。</p>
<h4 id="321">3.2.1 正负样本标记<a class="headerlink" href="#321" title="Permanent link">&para;</a></h4>
<p>在FastRCNN网络训练时：</p>
<ul>
<li>首先将与真实框ground truth（GT）交并比IOU大于0.5的候选区域设为正样本，类别的目标值是GT的类别</li>
<li>将与真实框ground truth（GT）交并比IOU小于0.5的候选区域设为负样本，类别的目标值是0</li>
</ul>
<h4 id="312-fastrcnn">3.1.2  FastRCNN的损失函数<a class="headerlink" href="#312-fastrcnn" title="Permanent link">&para;</a></h4>
<p>FastRCNN的输出由两部分组成：一部分是softmax层进行分类，输出类别有K个类别加上”背景”类，另一部分是回归bounding box regressor。也就是：</p>
<ul>
<li>一部分输出在K+1个类别上的离散概率分布（每个候选区域），<span><span class="MathJax_Preview">p=(p0,p1,...,pk)</span><script type="math/tex">p=(p0,p1,...,pk)</script></span>。通常，通过全连接层的K+1个输出上的Softmax来计算p。</li>
<li>另一部分输出对于由K个类别中的每一个检测框回归偏移，<span><span class="MathJax_Preview">t^{k}=(t_{x}^{k},t_{y}^{k},t_{w}^{k},t_{h}^{k})</span><script type="math/tex">t^{k}=(t_{x}^{k},t_{y}^{k},t_{w}^{k},t_{h}^{k})</script></span>。其中<span><span class="MathJax_Preview">t_k</span><script type="math/tex">t_k</script></span>指定相对于候选框的尺度不变转换和对数空间高度/宽度移位，与在RPN网络中是一样的。</li>
</ul>
<p>每个训练的候选区域用 <strong>分类目标值u和检测框回归目标值v标记</strong> 。背景样本用u=0来表示，对每个标记的候选区域使用多任务损失L以联合训练分类和检测框回归：</p>
<p><img alt="image-20200915111032596" src="../assets/image-20200915111032596.png" /></p>
<p>其中<span><span class="MathJax_Preview">L_{cls}(p, u) = -\log p_u</span><script type="math/tex">L_{cls}(p, u) = -\log p_u</script></span>，表示交叉熵损失，第二个损失<span><span class="MathJax_Preview">L_{loc}</span><script type="math/tex">L_{loc}</script></span>，是定义目标值和预测检测框的四元组之间的损失使用smoothL1损失计算，同样是只有正样本（非背景）的候选区域才计算回归损失，参数λ设为1。</p>
<h4 id="323">3.2.3.训练过程<a class="headerlink" href="#323" title="Permanent link">&para;</a></h4>
<p>FastRCNN的训练获取每张图片中的正负样本：</p>
<ul>
<li>对所有正样本根据IOU值进行排序，每张图片取前256个区域，将这些区域的坐标保存下来，作为该图片的训练样本</li>
<li>用于Softmax分类和检测框回归的全连接层的权重分别使用具有方差0.01和0.001的零均值高斯分布初始化，偏置初始化为0，特征提取网络使用ImageNet的预训练网络</li>
<li>使用梯度下降算法进行优化</li>
</ul>
<h4 id="324">3.2.4 实现<a class="headerlink" href="#324" title="Permanent link">&para;</a></h4>
<h5 id="1_2">1、正负样本设置<a class="headerlink" href="#1_2" title="Permanent link">&para;</a></h5>
<p>将proposal层产生的候选区域与目标真实值的计算交并比设置正负样本：</p>
<div class="highlight"><pre><span></span><code><span class="c1"># fastRCNN的正负样本设置</span>
<span class="c1"># 输入：RPN网络生成的候选区域，bbox是标记框，label是目标类别</span>
<span class="c1"># 输出：参与训练的候选区域rois_list,候选区域分类的目标值rcnn_target_matchs_list，回归的目标值rcnn_target_deltas_list</span>
<span class="n">rois_list</span><span class="p">,</span> <span class="n">rcnn_target_matchs_list</span><span class="p">,</span> <span class="n">rcnn_target_deltas_list</span> <span class="o">=</span> \
                <span class="n">model</span><span class="o">.</span><span class="n">bbox_target</span><span class="o">.</span><span class="n">build_targets</span><span class="p">(</span>
                    <span class="n">proposals_list</span><span class="p">,</span><span class="n">bbox</span><span class="p">,</span> <span class="n">label</span><span class="p">,</span> <span class="n">imagemeta</span><span class="p">)</span>
</code></pre></div>
<p>获取正样本：正样本是负责目标检测的候选区域，其目标值不是0，正样本的个数是64个</p>
<div class="highlight"><pre><span></span><code><span class="c1"># 获取正样本：</span>
<span class="n">positive_proposal</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">gather</span><span class="p">(</span><span class="n">rois_list</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">tf</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>
    <span class="n">tf</span><span class="o">.</span><span class="n">not_equal</span><span class="p">(</span><span class="n">rcnn_target_matchs_list</span><span class="p">,</span> <span class="mi">0</span><span class="p">))[:,</span> <span class="mi">1</span><span class="p">])</span>
<span class="c1"># positive_proposal.shape</span>
<span class="n">TensorShape</span><span class="p">([</span><span class="mi">64</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span>
</code></pre></div>
<p>将其展示在图像上：可以这些框跟真实值是非常接近的</p>
<div class="highlight"><pre><span></span><code><span class="c1"># 显示</span>
<span class="n">visualize</span><span class="o">.</span><span class="n">draw_boxes</span><span class="p">(</span><span class="n">rgd_image</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">positive_proposal</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span><span class="o">*</span><span class="mi">1216</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</code></pre></div>
<p><img alt="image-20201231104448218" src="../assets/image-20201231104448218.png" /></p>
<p>同样我们也可以获取负样本（背景），并绘制在图像上：</p>
<div class="highlight"><pre><span></span><code><span class="c1"># 负样本</span>
<span class="n">negtivate_proposal</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">gather</span><span class="p">(</span><span class="n">rois_list</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">tf</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>
    <span class="n">tf</span><span class="o">.</span><span class="n">equal</span><span class="p">(</span><span class="n">rcnn_target_matchs_list</span><span class="p">,</span> <span class="mi">0</span><span class="p">))[:,</span> <span class="mi">1</span><span class="p">])</span>
<span class="c1"># negtivate_proposal.shape</span>
<span class="n">TensorShape</span><span class="p">([</span><span class="mi">192</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span>
<span class="c1"># 显示</span>
<span class="n">visualize</span><span class="o">.</span><span class="n">draw_boxes</span><span class="p">(</span><span class="n">rgd_image</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">negtivate_proposal</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span><span class="o">*</span><span class="mi">1216</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</code></pre></div>
<p><img alt="image-20201231104707698" src="../assets/image-20201231104707698.png" /></p>
<h5 id="2_2">2、损失函数<a class="headerlink" href="#2_2" title="Permanent link">&para;</a></h5>
<p>损失函数计算是将网络预测结果和真实值进行比较，获取两者之间的差别。在这里我们需要将参与网络训练的候选区域进行ROIPooling后送入网络中训练。损失函数由两部分组成：分类和回归：</p>
<div class="highlight"><pre><span></span><code><span class="c1"># 将参与网络训练的候选区域rois_list送入到ROIpooling层中进行维度固定</span>
<span class="n">pooled_regions_list</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">roi_align</span><span class="p">(</span>
            <span class="p">(</span><span class="n">rois_list</span><span class="p">,</span> <span class="n">rcnn_feature_maps</span><span class="p">,</span> <span class="n">imagemeta</span><span class="p">),</span> <span class="n">training</span><span class="o">=</span><span class="kc">True</span><span class="err">）</span>
<span class="c1"># 送入网络中进行预测，得到预测结果</span>
<span class="n">rcnn_class_logits_list</span><span class="p">,</span> <span class="n">rcnn_probs_list</span><span class="p">,</span> <span class="n">rcnn_deltas_list</span> <span class="o">=</span> \
            <span class="n">model</span><span class="o">.</span><span class="n">bbox_head</span><span class="p">(</span><span class="n">pooled_regions_list</span><span class="p">,</span> <span class="n">training</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="c1"># 计算损失函数：分类和回归</span>
<span class="c1"># 输入：网络的预测结果和目标值</span>
<span class="n">rcnn_class_loss</span><span class="p">,</span> <span class="n">rcnn_bbox_loss</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">bbox_head</span><span class="o">.</span><span class="n">loss</span><span class="p">(</span>
                <span class="n">rcnn_class_logits_list</span><span class="p">,</span> <span class="n">rcnn_deltas_list</span><span class="p">,</span> 
                <span class="n">rcnn_target_matchs_list</span><span class="p">,</span> <span class="n">rcnn_target_deltas_list</span><span class="p">)</span>  
<span class="c1"># 分类损失rcnn_class_loss</span>
<span class="o">&lt;</span><span class="n">tf</span><span class="o">.</span><span class="n">Tensor</span><span class="p">:</span> <span class="n">shape</span><span class="o">=</span><span class="p">(),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">float32</span><span class="p">,</span> <span class="n">numpy</span><span class="o">=</span><span class="mf">0.56958425</span><span class="o">&gt;</span>
<span class="c1"># 回归损失rcnn_bbox_loss</span>
<span class="o">&lt;</span><span class="n">tf</span><span class="o">.</span><span class="n">Tensor</span><span class="p">:</span> <span class="n">shape</span><span class="o">=</span><span class="p">(),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">float32</span><span class="p">,</span> <span class="n">numpy</span><span class="o">=</span><span class="mf">0.28708345</span><span class="o">&gt;</span>
</code></pre></div>
<p>接下来使用梯度下降算法进行预测即可</p>
<h3 id="33">3.3 共享卷积训练<a class="headerlink" href="#33" title="Permanent link">&para;</a></h3>
<p>用fastRCNN检测网络初始化RPN训练，但是固定共享的卷积层，并且只微调RPN独有的层，现在两个网络共享卷积层了，接下来保持共享的卷积层固定，微调Fast R-CNN的fc层。这样，RPN网络和Fast R-CNN网络共享相同的卷积层，构成一个统一的网络。</p>
<p>Faster R-CNN还有一种端到端的训练方式，可以一次完成训练，将RPN loss与Fast RCNN loss相加，然后进行梯度下降优化，更新参数。</p>
<h2 id="4">4 端到端训练<a class="headerlink" href="#4" title="Permanent link">&para;</a></h2>
<p>前面我们已经介绍了网络模型架构和预测结果，在网络预测前我们需要对网络进行训练，接下来使用端到端的方式进行模型训练，基本步骤是：</p>
<p>1、加载数据集：我们在这里使用VOC数据集，所以需要加载VOC数据集</p>
<p>2、模型实例化：加载faster RCNN模型</p>
<p>3、模型训练：计算损失函数，使用反向传播算法对模型进行训练</p>
<p>完成网络的训练。首先导入相关的工具包：</p>
<div class="highlight"><pre><span></span><code><span class="c1"># 数据集加载</span>
<span class="kn">from</span> <span class="nn">detection.datasets</span> <span class="kn">import</span> <span class="n">pascal_voc</span>
<span class="c1"># 深度学习框架</span>
<span class="kn">import</span> <span class="nn">tensorflow</span> <span class="k">as</span> <span class="nn">tf</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="c1"># 绘图</span>
<span class="kn">from</span> <span class="nn">matplotlib</span> <span class="kn">import</span> <span class="n">pyplot</span> <span class="k">as</span> <span class="n">plt</span>
<span class="c1"># 要训练的模型</span>
<span class="kn">from</span> <span class="nn">detection.models.detectors</span> <span class="kn">import</span> <span class="n">faster_rcnn</span>
</code></pre></div>
<h3 id="41">4.1 数据加载<a class="headerlink" href="#41" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="c1"># 加载数据集</span>
<span class="n">train_dataset</span> <span class="o">=</span> <span class="n">pascal_voc</span><span class="o">.</span><span class="n">pascal_voc</span><span class="p">(</span><span class="s1">&#39;train&#39;</span><span class="p">)</span>
<span class="c1"># 数据的类别： train_dataset.classes</span>
<span class="p">[</span><span class="s1">&#39;background&#39;</span><span class="p">,</span>
 <span class="s1">&#39;person&#39;</span><span class="p">,</span>
 <span class="s1">&#39;aeroplane&#39;</span><span class="p">,</span>
 <span class="s1">&#39;bicycle&#39;</span><span class="p">,</span>
 <span class="s1">&#39;bird&#39;</span><span class="p">,</span>
 <span class="s1">&#39;boat&#39;</span><span class="p">,</span>
 <span class="s1">&#39;bottle&#39;</span><span class="p">,</span>
 <span class="s1">&#39;bus&#39;</span><span class="p">,</span>
 <span class="s1">&#39;car&#39;</span><span class="p">,</span>
 <span class="s1">&#39;cat&#39;</span><span class="p">,</span>
 <span class="s1">&#39;chair&#39;</span><span class="p">,</span>
 <span class="s1">&#39;cow&#39;</span><span class="p">,</span>
 <span class="s1">&#39;diningtable&#39;</span><span class="p">,</span>
 <span class="s1">&#39;dog&#39;</span><span class="p">,</span>
 <span class="s1">&#39;horse&#39;</span><span class="p">,</span>
 <span class="s1">&#39;motorbike&#39;</span><span class="p">,</span>
 <span class="s1">&#39;pottedplant&#39;</span><span class="p">,</span>
 <span class="s1">&#39;sheep&#39;</span><span class="p">,</span>
 <span class="s1">&#39;sofa&#39;</span><span class="p">,</span>
 <span class="s1">&#39;train&#39;</span><span class="p">,</span>
 <span class="s1">&#39;tvmonitor&#39;</span><span class="p">]</span>
<span class="c1"># 数据类别数量：21</span>
<span class="n">num_classes</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">train_dataset</span><span class="o">.</span><span class="n">classes</span><span class="p">)</span>
</code></pre></div>
<h3 id="42">4.2. 模型实例化<a class="headerlink" href="#42" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="c1"># 指定数据集中类别个数</span>
<span class="n">model</span> <span class="o">=</span> <span class="n">faster_rcnn</span><span class="o">.</span><span class="n">FasterRCNN</span><span class="p">(</span><span class="n">num_classes</span><span class="o">=</span><span class="n">num_classes</span><span class="p">)</span>
</code></pre></div>
<h3 id="43">4.3 模型训练<a class="headerlink" href="#43" title="Permanent link">&para;</a></h3>
<p>模型训练也就是要使用损失函数，进行反向传播，利用优化器进行参数更新，训练的流程是：</p>
<p>1、指定优化器：在这里我们使用加动量的SGD方法</p>
<p>2、设置epoch，进行遍历获取batch数据送入网络中进行预测</p>
<p>3、计算损失函数，使用反向传播更新参数，我们使用tf.GradientTape实现：</p>
<ul>
<li>
<p>定义上下文环境：tf.GradientTape</p>
</li>
<li>
<p>计算损失函数loss</p>
</li>
<li>
<p>使用 <code>tape.gradient(loss,model.trainable_variables)</code> 自动计算梯度，loss是损失结果，trainable_variables为所有需要训练的变量。</p>
</li>
<li>使用 <code>optimizer.apply_gradients(zip(grads,model.trainable_variables))</code> 自动更新模型参数，zip(grads, trainable_variables)将梯度和参数关联起来，然后apply_gradients会自动的利用梯度对参数进行更新。</li>
</ul>
<p>接下来我们按照这个流程完成模型训练。</p>
<div class="highlight"><pre><span></span><code><span class="c1"># 1.定义优化器</span>
<span class="n">optimizer</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">keras</span><span class="o">.</span><span class="n">optimizers</span><span class="o">.</span><span class="n">SGD</span><span class="p">(</span><span class="mf">1e-3</span><span class="p">,</span> <span class="n">momentum</span><span class="o">=</span><span class="mf">0.9</span><span class="p">,</span> <span class="n">nesterov</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="c1"># 模型优化</span>
<span class="n">loss_his</span> <span class="o">=</span> <span class="p">[]</span>
<span class="c1"># 2.设置epoch，进行遍历获取batch数据送入网络中进行预测</span>
<span class="k">for</span> <span class="n">epoch</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">7</span><span class="p">):</span>
    <span class="c1"># 获取索引</span>
    <span class="n">indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">train_dataset</span><span class="o">.</span><span class="n">num_gtlabels</span><span class="p">)</span>
    <span class="c1"># 打乱</span>
    <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">shuffle</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span>
    <span class="c1"># 迭代次数</span>
    <span class="nb">iter</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">train_dataset</span><span class="o">.</span><span class="n">num_gtlabels</span><span class="o">/</span><span class="n">train_dataset</span><span class="o">.</span><span class="n">batch_size</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">iter</span><span class="p">):</span>
        <span class="c1"># 获取batch数据索引</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">indices</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
        <span class="c1"># 获取batch_size</span>
        <span class="n">batch_image</span><span class="p">,</span><span class="n">batch_metas</span><span class="p">,</span><span class="n">batch_bboxes</span><span class="p">,</span><span class="n">batch_label</span> <span class="o">=</span> <span class="n">train_dataset</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
        <span class="c1"># 3.模型训练，计算损失函数，使用反向传播更新参数</span>
        <span class="c1"># 3.1 定义作用域</span>
        <span class="k">with</span> <span class="n">tf</span><span class="o">.</span><span class="n">GradientTape</span><span class="p">()</span> <span class="k">as</span> <span class="n">tape</span><span class="p">:</span>
            <span class="c1"># 3.2 计算损失函数</span>
            <span class="n">rpn_class_loss</span><span class="p">,</span><span class="n">rpn_bbox_loss</span><span class="p">,</span><span class="n">rcnn_class_loss</span><span class="p">,</span><span class="n">rcnn_bbox_loss</span> <span class="o">=</span> <span class="n">model</span><span class="p">((</span><span class="n">batch_image</span><span class="p">,</span><span class="n">batch_metas</span><span class="p">,</span><span class="n">batch_bboxes</span><span class="p">,</span><span class="n">batch_label</span><span class="p">),</span><span class="n">training</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="c1"># 总损失</span>
            <span class="n">loss</span> <span class="o">=</span> <span class="n">rpn_class_loss</span><span class="o">+</span><span class="n">rpn_bbox_loss</span><span class="o">+</span><span class="n">rcnn_class_loss</span><span class="o">+</span><span class="n">rcnn_bbox_loss</span>
            <span class="c1"># 3.3 计算梯度</span>
            <span class="n">grads</span> <span class="o">=</span> <span class="n">tape</span><span class="o">.</span><span class="n">gradient</span><span class="p">(</span><span class="n">loss</span><span class="p">,</span><span class="n">model</span><span class="o">.</span><span class="n">trainable_variables</span><span class="p">)</span>
            <span class="c1"># 3.4 更新参数值</span>
            <span class="n">optimizer</span><span class="o">.</span><span class="n">apply_gradients</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">grads</span><span class="p">,</span><span class="n">model</span><span class="o">.</span><span class="n">trainable_variables</span><span class="p">))</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;epoch:</span><span class="si">%d</span><span class="s2">,batch:</span><span class="si">%d</span><span class="s2">,loss:</span><span class="si">%f</span><span class="s2">&quot;</span><span class="o">%</span><span class="p">(</span><span class="n">epoch</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">idx</span><span class="p">,</span><span class="n">loss</span><span class="p">))</span>
            <span class="n">loss_his</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">loss</span><span class="p">)</span>
</code></pre></div>
<p>结果为：</p>
<div class="highlight"><pre><span></span><code><span class="n">epoch</span><span class="err">：</span><span class="mi">1</span><span class="p">,</span> <span class="n">loss</span><span class="err">：</span><span class="mf">147.117371</span>
<span class="n">epoch</span><span class="err">：</span><span class="mi">2</span><span class="p">,</span> <span class="n">loss</span><span class="err">：</span><span class="mf">72.580498</span>
<span class="n">epoch</span><span class="err">：</span><span class="mi">3</span><span class="p">,</span> <span class="n">loss</span><span class="err">：</span><span class="mf">79.347351</span>
<span class="n">epoch</span><span class="err">：</span><span class="mi">4</span><span class="p">,</span> <span class="n">loss</span><span class="err">：</span><span class="mf">41.220577</span>
<span class="n">epoch</span><span class="err">：</span><span class="mi">5</span><span class="p">,</span> <span class="n">loss</span><span class="err">：</span><span class="mf">5.238140</span>
<span class="n">epoch</span><span class="err">：</span><span class="mi">6</span><span class="p">,</span> <span class="n">loss</span><span class="err">：</span><span class="mf">2.924250</span>
<span class="n">epoch</span><span class="err">：</span><span class="mi">7</span><span class="p">,</span> <span class="n">loss</span><span class="err">：</span><span class="mf">5.287500</span>
</code></pre></div>
<p>损失函数的变换如下图所示：</p>
<div class="highlight"><pre><span></span><code><span class="c1"># 绘制损失函数变化的曲线</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">loss_his</span><span class="p">)),[</span><span class="n">loss</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span> <span class="k">for</span> <span class="n">loss</span> <span class="ow">in</span> <span class="n">loss_his</span><span class="p">])</span>
<span class="n">plt</span><span class="o">.</span><span class="n">grid</span><span class="p">()</span>
</code></pre></div>
<p><img alt="image-20200921164738442" src="../assets/image-20200921164738442.png" /></p>
<p>当我们训练好模型后，就可以使用训练好的模型进行预测了，也就是本节开头给大家介绍的内容。</p>
<hr />
<p><strong>总结</strong></p>
<ul>
<li>熟悉FasterRCNN目标检测的思想</li>
</ul>
<p>利用CNN网络进行特征提取，利用RPN生成候选区域，最后进行分类和回归</p>
<ul>
<li>知道anchor的思想</li>
</ul>
<p>anchor技术将检测问题转换为**"这个固定参考框中有没有目标，目标框偏离参考框多远"**，不再需要多尺度遍历滑窗</p>
<ul>
<li>掌握RPN网络是如何进行候选区域的生成的</li>
</ul>
<p>通过softmax判断anchors属于positive或者negative，再利用bounding box regression修正anchors获得精确的proposals</p>
<ul>
<li>掌握ROIPooling的使用方法</li>
</ul>
<p>RoIpooling使用最大池化将任何有效的RoI区域内的特征转换成具有H×W的固定空间范围的小feature map</p>
<ul>
<li>知道fasterRCNN的训练方法</li>
</ul>
<p>分步训练：RPN网络，fastrcnn训练，共享网络训练，端到端的网络训练</p>
                
              
              
                


              
            </article>
          </div>
        </div>
        
      </main>
      
        
<footer class="md-footer">
  
    <nav class="md-footer__inner md-grid" aria-label="Footer">
      
        <a href="../02.RCNN/index.html" class="md-footer__link md-footer__link--prev" rel="prev">
          <div class="md-footer__button md-icon">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12z"/></svg>
          </div>
          <div class="md-footer__title">
            <div class="md-ellipsis">
              <span class="md-footer__direction">
                Previous
              </span>
              RCNN网络基础
            </div>
          </div>
        </a>
      
      
        <a href="../04.yolo/index.html" class="md-footer__link md-footer__link--next" rel="next">
          <div class="md-footer__title">
            <div class="md-ellipsis">
              <span class="md-footer__direction">
                Next
              </span>
              YOLO系列算法
            </div>
          </div>
          <div class="md-footer__button md-icon">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M4 11v2h12l-5.5 5.5 1.42 1.42L19.84 12l-7.92-7.92L10.5 5.5 16 11H4z"/></svg>
          </div>
        </a>
      
    </nav>
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-footer-copyright">
        
        Made with
        <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
          Material for MkDocs
        </a>
        
      </div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    <script id="__config" type="application/json">{"base": "../..", "features": [], "translations": {"clipboard.copy": "Copy to clipboard", "clipboard.copied": "Copied to clipboard", "search.config.lang": "en", "search.config.pipeline": "trimmer, stopWordFilter", "search.config.separator": "[\\s\\-]+", "search.placeholder": "Search", "search.result.placeholder": "Type to start searching", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.term.missing": "Missing"}, "search": "../../assets/javascripts/workers/search.d351de03.min.js", "version": null}</script>
    
    
      <script src="../../assets/javascripts/bundle.a1609d9a.min.js"></script>
      
        <script src="../../js/extra.js"></script>
      
        <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML"></script>
      
    
  </body>
</html>